C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_GPS_TAU1201
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_GPS_TAU1201.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\seekfree_peripheral\SEEKFREE_GPS_TAU1201.c XSMALL I
                    -NTR2 FLOAT64 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\s
                    -eekfree_libraries;..\seekfree_peripheral;..\libraries) DEBUG PRINT(.\Out_File\SEEKFREE_GPS_TAU1201.lst) TABS(2) OBJECT(.
                    -\Out_File\SEEKFREE_GPS_TAU1201.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library ¼´£¨AI8051U ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * AI8051U ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MDK FOR C251
   28          * ÊÊÓÃÆ½Ì¨          AI8051U
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33          * 2024-08-01        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * ½ÓÏß¶¨Òå£º
   37          *                  ------------------------------------
   38          *                  Ä£¿é¹Ü½Å             µ¥Æ¬»ú¹Ü½Å
   39          *                  RX                  ²é¿´ zf_device_gps_tau1201.h ÖÐ GPS_TAU1201_RX ºê¶¨Òå
   40          *                  TX                  ²é¿´ zf_device_gps_tau1201.h ÖÐ GPS_TAU1201_TX ºê¶¨Òå
   41          *                  VCC                 3.3VµçÔ´
   42          *                  GND                 µçÔ´µØ
   43          *                  ------------------------------------
   44          *********************************************************************************************************
             -***********/
   45          
   46          #include "math.h"
   47          #include "zf_uart.h"
   48          #include "zf_fifo.h"
   49          #include "zf_delay.h"
   50          #include "zf_function.h"
   51          
   52          #include "SEEKFREE_GPS_TAU1201.h"
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 2   

   53          
   54          #pragma warning disable = 183
   55          
   56          #define GPS_TAU1201_BUFFER_SIZE     ( 128 )
   57          
   58          uint8                       gps_tau1201_flag = 0;                                   // 1£º²É¼¯Íê³ÉµÈ´ý´¦À
             -íÊý¾Ý 0£ºÃ»ÓÐ²É¼¯Íê³É
   59          gps_info_struct             gps_tau1201;                                            // GPS½âÎöÖ®ºóµÄÊý¾Ý
   60          
   61          static  uint8               gps_tau1201_state = 0;                                  // 1£ºGPS³õÊ¼»¯Íê³É
   62          static  fifo_struct         gps_tau1201_receiver_fifo;                              //
   63          static  uint8               gps_tau1201_receiver_buffer[GPS_TAU1201_BUFFER_SIZE];   // Êý¾Ý´æ·ÅÊý×é
   64          
   65          gps_state_enum              gps_gga_state = GPS_STATE_RECEIVING;                    // gga Óï¾ä×´Ì¬
   66          gps_state_enum              gps_rmc_state = GPS_STATE_RECEIVING;                    // rmc Óï¾ä×´Ì¬
   67          
   68          static  uint8               gps_gga_buffer[GPS_TAU1201_BUFFER_SIZE];                // GGAÓï¾ä»º³åÇø
   69          static  uint8               gps_rmc_buffer[GPS_TAU1201_BUFFER_SIZE];                // RMCÓï¾ä»º³åÇø
   70          
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          // º¯Êý¼ò½é     »ñÈ¡Ö¸¶¨ ',' ºóÃæµÄË÷Òý
   73          // ²ÎÊýËµÃ÷     num             µÚ¼¸¸ö¶ººÅ
   74          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®
   75          // ·µ»Ø²ÎÊý     uint8           ·µ»ØË÷Òý
   76          // Ê¹ÓÃÊ¾Àý     get_parameter_index(1, s);
   77          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
   78          //-------------------------------------------------------------------------------------------------------
             -------------
   79          static uint8 get_parameter_index (uint8 num, char *str)
   80          {
   81   1          uint8 i = 0, j = 0;
   82   1          char *temp = strchr(str, '\n');
   83   1          uint8 len = 0, len1 = 0;
   84   1      
   85   1          if(NULL != temp)
   86   1          {
   87   2              len = (uint8)((uint32)temp - (uint32)str + 1);
   88   2          }
   89   1      
   90   1          for(i = 0; i < len; i ++)
   91   1          {
   92   2              if(',' == str[i])
   93   2              {
   94   3                  j ++;
   95   3              }
   96   2              if(j == num)
   97   2              {
   98   3                  len1 =  i + 1;
   99   3                  break;
  100   3              }
  101   2          }
  102   1      
  103   1          return len1;
  104   1      }
  105          
  106          //-------------------------------------------------------------------------------------------------------
             -------------
  107          // º¯Êý¼ò½é     ¸ø¶¨×Ö·û´®µÚÒ»¸ö ',' Ö®Ç°µÄÊý¾Ý×ª»»Îªint
  108          // ²ÎÊýËµÃ÷     *s              ×Ö·û´®
  109          // ·µ»Ø²ÎÊý     float           ·µ»ØÊýÖµ
  110          // Ê¹ÓÃÊ¾Àý     get_int_number(&buf[get_parameter_index(7, buf)]);
  111          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  112          //-------------------------------------------------------------------------------------------------------
             -------------
  113          static int get_int_number (char *s)
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 3   

  114          {
  115   1          char buf[10];
  116   1          uint8 i = 0;
  117   1          int return_value = 0;
  118   1          i = get_parameter_index(1, s);
  119   1          i = i - 1;
  120   1          strncpy(buf, s, i);
  121   1          buf[i] = 0;
  122   1          return_value = func_str_to_int(buf);
  123   1          return return_value;
  124   1      }
  125          
  126          //-------------------------------------------------------------------------------------------------------
             -------------
  127          // º¯Êý¼ò½é     ¸ø¶¨×Ö·û´®µÚÒ»¸ö ',' Ö®Ç°µÄÊý¾Ý×ª»»Îªfloat
  128          // ²ÎÊýËµÃ÷     *s              ×Ö·û´®
  129          // ·µ»Ø²ÎÊý     float           ·µ»ØÊýÖµ
  130          // Ê¹ÓÃÊ¾Àý     get_float_number(&buf[get_parameter_index(8, buf)]);
  131          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  132          //-------------------------------------------------------------------------------------------------------
             -------------
  133          static float get_float_number (char *s)
  134          {
  135   1          uint8 i = 0;
  136   1          char buf[15];
  137   1          float return_value = 0;
  138   1      
  139   1          i = get_parameter_index(1, s);
  140   1          i = i - 1;
  141   1          strncpy(buf, s, i);
  142   1          buf[i] = 0;
  143   1          return_value = (float)func_str_to_double(buf);
  144   1          return return_value;
  145   1      }
  146          
  147          //-------------------------------------------------------------------------------------------------------
             -------------
  148          // º¯Êý¼ò½é     ¸ø¶¨×Ö·û´®µÚÒ»¸ö ',' Ö®Ç°µÄÊý¾Ý×ª»»Îªdouble
  149          // ²ÎÊýËµÃ÷     *s              ×Ö·û´®
  150          // ·µ»Ø²ÎÊý     double          ·µ»ØÊýÖµ
  151          // Ê¹ÓÃÊ¾Àý     get_double_number(&buf[get_parameter_index(3, buf)]);
  152          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  153          //-------------------------------------------------------------------------------------------------------
             -------------
  154          static double get_double_number (char *s)
  155          {
  156   1          uint8 i = 0;
  157   1          char buf[15];
  158   1          double return_value = 0;
  159   1      
  160   1          i = get_parameter_index(1, s);
  161   1          i = i - 1;
  162   1          strncpy(buf, s, i);
  163   1          buf[i] = 0;
  164   1          return_value = func_str_to_double(buf);
  165   1          return return_value;
  166   1      }
  167          
  168          //-------------------------------------------------------------------------------------------------------
             -------------
  169          // º¯Êý¼ò½é     ÊÀ½çÊ±¼ä×ª»»Îª±±¾©Ê±¼ä
  170          // ²ÎÊýËµÃ÷     *time           ±£´æµÄÊ±¼ä
  171          // ·µ»Ø²ÎÊý     void
  172          // Ê¹ÓÃÊ¾Àý     utc_to_btc(&gps->time);
  173          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  174          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 4   

             -------------
  175          static void utc_to_btc (gps_time_struct *time)
  176          {
  177   1          uint8 day_num = 0;
  178   1      
  179   1          time->hour = time->hour + 8;
  180   1          if(23 < time->hour)
  181   1          {
  182   2              time->hour -= 24;
  183   2              time->day += 1;
  184   2      
  185   2              if(2 == time->month)
  186   2              {
  187   3                  day_num = 28;
  188   3                  if((0 == time->year % 4 && 0 != time->year % 100) || 0 == time->year % 400) // ÅÐ¶ÏÊÇ·ñÎªÈòÄê
  189   3                  {
  190   4                      day_num ++;                                                     // ÈòÔÂ 2ÔÂÎª29Ìì
  191   4                  }
  192   3              }
  193   2              else
  194   2              {
  195   3                  day_num = 31;                                                       // 1 3 5 7 8 10 12ÕâÐ©ÔÂ·
             -ÝÎª31Ìì
  196   3                  if(4  == time->month || 6  == time->month || 9  == time->month || 11 == time->month )
  197   3                  {
  198   4                      day_num = 30;
  199   4                  }
  200   3              }
  201   2      
  202   2              if(time->day > day_num)
  203   2              {
  204   3                  time->day = 1;
  205   3                  time->month ++;
  206   3                  if(12 < time->month)
  207   3                  {
  208   4                      time->month -= 12;
  209   4                      time->year ++;
  210   4                  }
  211   3              }
  212   2          }
  213   1      }
  214          
  215          //-------------------------------------------------------------------------------------------------------
             -------------
  216          // º¯Êý¼ò½é     RMCÓï¾ä½âÎö
  217          // ²ÎÊýËµÃ÷     *line           ½ÓÊÕµ½µÄÓï¾äÐÅÏ¢
  218          // ²ÎÊýËµÃ÷     *gps            ±£´æ½âÎöºóµÄÊý¾Ý
  219          // ·µ»Ø²ÎÊý     uint8           1£º½âÎö³É¹¦ 0£ºÊý¾ÝÓÐÎÊÌâ²»ÄÜ½âÎö
  220          // Ê¹ÓÃÊ¾Àý     gps_gnrmc_parse((char *)data_buffer, &gps_tau1201);
  221          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  222          //-------------------------------------------------------------------------------------------------------
             -------------
  223          static uint8 gps_gnrmc_parse (char *line, gps_info_struct *gps)
  224          {
  225   1          uint8 state = 0, temp = 0;
  226   1      
  227   1          double  latitude = 0;                                                       // Î³¶È
  228   1          double  longitude = 0;                                                      // ¾­¶È
  229   1      
  230   1          double lati_cent_tmp = 0, lati_second_tmp = 0;
  231   1          double long_cent_tmp = 0, long_second_tmp = 0;
  232   1          float speed_tmp = 0;
  233   1          char *buf = line;
  234   1          uint8 return_state = 0;
  235   1      
  236   1          state = buf[get_parameter_index(2, buf)];
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 5   

  237   1      
  238   1          gps->state = 0;
  239   1          if('A' == state)                                                            // Èç¹ûÊý¾ÝÓÐÐ§ Ôò½âÎöÊý¾
             -Ý
  240   1          {
  241   2              return_state = 1;
  242   2              gps->state = 1;
  243   2              gps -> ns               = buf[get_parameter_index(4, buf)];
  244   2              gps -> ew               = buf[get_parameter_index(6, buf)];
  245   2      
  246   2              latitude                = get_double_number(&buf[get_parameter_index(3, buf)]);
  247   2              longitude               = get_double_number(&buf[get_parameter_index(5, buf)]);
  248   2      
  249   2              gps->latitude_degree    = (int)latitude / 100;                          // Î³¶È×ª»»Îª¶È·ÖÃë
  250   2              lati_cent_tmp           = (latitude - gps->latitude_degree * 100);
  251   2              gps->latitude_cent      = (int)lati_cent_tmp;
  252   2              lati_second_tmp         = (lati_cent_tmp - gps->latitude_cent) * 6000;
  253   2              gps->latitude_second    = (int)lati_second_tmp;
  254   2      
  255   2              gps->longitude_degree   = (int)longitude / 100;                         // ¾­¶È×ª»»Îª¶È·ÖÃë
  256   2              long_cent_tmp           = (longitude - gps->longitude_degree * 100);
  257   2              gps->longitude_cent     = (int)long_cent_tmp;
  258   2              long_second_tmp         = (long_cent_tmp - gps->longitude_cent) * 6000;
  259   2              gps->longitude_second   = (int)long_second_tmp;
  260   2      
  261   2              gps->latitude   = gps->latitude_degree + lati_cent_tmp / 60;
  262   2              gps->longitude  = gps->longitude_degree + long_cent_tmp / 60;
  263   2      
  264   2              speed_tmp       = get_float_number(&buf[get_parameter_index(7, buf)]);  // ËÙ¶È(º£Àï/Ð¡Ê±)
  265   2              gps->speed      = speed_tmp * 1.85f;                                    // ×ª»»Îª¹«Àï/Ð¡Ê±
  266   2              gps->direction  = get_float_number(&buf[get_parameter_index(8, buf)]);  // ½Ç¶È
  267   2          }
  268   1      
  269   1          // ÔÚ¶¨Î»Ã»ÓÐÉúÐ§Ç°Ò²ÊÇÓÐÊ±¼äÊý¾ÝµÄ£¬¿ÉÒÔÖ±½Ó½âÎö
  270   1          gps->time.hour    = (buf[7] - '0') * 10 + (buf[8] - '0');                   // Ê±¼ä
  271   1          gps->time.minute  = (buf[9] - '0') * 10 + (buf[10] - '0');
  272   1          gps->time.second  = (buf[11] - '0') * 10 + (buf[12] - '0');
  273   1          temp = get_parameter_index(9, buf);
  274   1          gps->time.day     = (buf[temp + 0] - '0') * 10 + (buf[temp + 1] - '0');     // ÈÕÆÚ
  275   1          gps->time.month   = (buf[temp + 2] - '0') * 10 + (buf[temp + 3] - '0');
  276   1          gps->time.year    = (buf[temp + 4] - '0') * 10 + (buf[temp + 5] - '0') + 2000;
  277   1      
  278   1          utc_to_btc(&gps->time);
  279   1      
  280   1          return return_state;
  281   1      }
  282          
  283          //-------------------------------------------------------------------------------------------------------
             -------------
  284          // º¯Êý¼ò½é     GGAÓï¾ä½âÎö
  285          // ²ÎÊýËµÃ÷     *line           ½ÓÊÕµ½µÄÓï¾äÐÅÏ¢
  286          // ²ÎÊýËµÃ÷     *gps            ±£´æ½âÎöºóµÄÊý¾Ý
  287          // ·µ»Ø²ÎÊý     uint8           1£º½âÎö³É¹¦ 0£ºÊý¾ÝÓÐÎÊÌâ²»ÄÜ½âÎö
  288          // Ê¹ÓÃÊ¾Àý     gps_gngga_parse((char *)data_buffer, &gps_tau1201);
  289          // ±¸×¢ÐÅÏ¢     ÄÚ²¿Ê¹ÓÃ
  290          //-------------------------------------------------------------------------------------------------------
             -------------
  291          static uint8 gps_gngga_parse (char *line, gps_info_struct *gps)
  292          {
  293   1          uint8 state = 0;
  294   1          char *buf = line;
  295   1          uint8 return_state = 0;
  296   1      
  297   1          state = buf[get_parameter_index(2, buf)];
  298   1      
  299   1          if(',' != state)
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 6   

  300   1          {
  301   2              gps->satellite_used = (uint8)get_int_number(&buf[get_parameter_index(7, buf)]);
  302   2              gps->height         = get_float_number(&buf[get_parameter_index(9, buf)]) + get_float_number(&buf
             -[get_parameter_index(11, buf)]);  // ¸ß¶È = º£°Î¸ß¶È + µØÇòÍÖÇòÃæÏà¶Ô´óµØË®×¼ÃæµÄ¸ß¶È
  303   2              return_state = 1;
  304   2          }
  305   1      
  306   1          return return_state;
  307   1      }
  308          
  309          //-------------------------------------------------------------------------------------------------------
             -------------
  310          // º¯Êý¼ò½é     ¼ÆËã´ÓµÚÒ»¸öµãµ½µÚ¶þ¸öµãµÄ¾àÀë
  311          // ²ÎÊýËµÃ÷     latitude1       µÚÒ»¸öµãµÄÎ³¶È
  312          // ²ÎÊýËµÃ÷     longitude1      µÚÒ»¸öµãµÄ¾­¶È
  313          // ²ÎÊýËµÃ÷     latitude2       µÚ¶þ¸öµãµÄÎ³¶È
  314          // ²ÎÊýËµÃ÷     longitude2      µÚ¶þ¸öµãµÄ¾­¶È
  315          // ·µ»Ø²ÎÊý     double          ·µ»ØÁ½µã¾àÀë
  316          // Ê¹ÓÃÊ¾Àý     get_two_points_distance(latitude1_1, longitude1, latitude2, longitude2);
  317          // ±¸×¢ÐÅÏ¢
  318          //-------------------------------------------------------------------------------------------------------
             -------------
  319          double get_two_points_distance (double latitude1, double longitude1, double latitude2, double longitude2)
  320          {
  321   1          const double EARTH_RADIUS = 6378137;                                        // µØÇò°ë¾¶(µ¥Î»£ºm)
  322   1          double rad_latitude1 = 0;
  323   1          double rad_latitude2 = 0;
  324   1          double rad_longitude1 = 0;
  325   1          double rad_longitude2 = 0;
  326   1          double distance = 0;
  327   1          double a = 0;
  328   1          double b = 0;
  329   1      
  330   1          rad_latitude1 = ANGLE_TO_RAD(latitude1);                                    // ¸ù¾Ý½Ç¶È¼ÆËã»¡¶È
  331   1          rad_latitude2 = ANGLE_TO_RAD(latitude2);
  332   1          rad_longitude1 = ANGLE_TO_RAD(longitude1);
  333   1          rad_longitude2 = ANGLE_TO_RAD(longitude2);
  334   1      
  335   1          a = rad_latitude1 - rad_latitude2;
  336   1          b = rad_longitude1 - rad_longitude2;
  337   1      
  338   1          distance = 2 * asin(sqrt(pow(sin(a / 2), 2) + cos(rad_latitude1) * cos(rad_latitude2) * pow(sin(b / 2
             -), 2)));   // google maps ÀïÃæÊµÏÖµÄËã·¨
  339   1          distance = distance * EARTH_RADIUS;
  340   1      
  341   1          return distance;
  342   1      }
  343          
  344          //-------------------------------------------------------------------------------------------------------
             -------------
  345          // º¯Êý¼ò½é     ¼ÆËã´ÓµÚÒ»¸öµãµ½µÚ¶þ¸öµãµÄ·½Î»½Ç
  346          // ²ÎÊýËµÃ÷     latitude1       µÚÒ»¸öµãµÄÎ³¶È
  347          // ²ÎÊýËµÃ÷     longitude1      µÚÒ»¸öµãµÄ¾­¶È
  348          // ²ÎÊýËµÃ÷     latitude2       µÚ¶þ¸öµãµÄÎ³¶È
  349          // ²ÎÊýËµÃ÷     longitude2      µÚ¶þ¸öµãµÄ¾­¶È
  350          // ·µ»Ø²ÎÊý     double          ·µ»Ø·½Î»½Ç£¨0ÖÁ360£©
  351          // Ê¹ÓÃÊ¾Àý     get_two_points_azimuth(latitude1_1, longitude1, latitude2, longitude2);
  352          // ±¸×¢ÐÅÏ¢
  353          //-------------------------------------------------------------------------------------------------------
             -------------
  354          double get_two_points_azimuth (double latitude1, double longitude1, double latitude2, double longitude2)
  355          {
  356   1        double x = 0;
  357   1        double y = 0;
  358   1        double angle = 0;
  359   1        
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 7   

  360   1        
  361   1          latitude1 = ANGLE_TO_RAD(latitude1);
  362   1          latitude2 = ANGLE_TO_RAD(latitude2);
  363   1          longitude1 = ANGLE_TO_RAD(longitude1);
  364   1          longitude2 = ANGLE_TO_RAD(longitude2);
  365   1      
  366   1          x = sin(longitude2 - longitude1) * cos(latitude2);
  367   1          y = cos(latitude1) * sin(latitude2) - sin(latitude1) * cos(latitude2) * cos(longitude2 - longitude1);
  368   1      
  369   1          angle = RAD_TO_ANGLE(atan(x/y));
  370   1      
  371   1        
  372   1          if (y == 0 && x == 0) return 0;
  373   1      
  374   1          if (y == 0)
  375   1          {
  376   2              if (x > 0) return 90;
  377   2              else angle = -90;
  378   2          }
  379   1      
  380   1          else if (x == 0)
  381   1          {
  382   2              if (y > 0) return 0;
  383   2              else angle = -180.0f;
  384   2          }
  385   1        else
  386   1        {
  387   2          if (y < 0 && angle > 0) angle -= 180.0f;
  388   2          else if (y < 0 && angle < 0) angle += 180.0f;
  389   2        }
  390   1      
  391   1        if(angle >= 360)
  392   1        {
  393   2          angle = angle - 360;
  394   2        }
  395   1        else if(angle < 0)
  396   1        {
  397   2          angle = angle + 360;
  398   2        }
  399   1      
  400   1          return angle;
  401   1      }
  402          
  403          //-------------------------------------------------------------------------------------------------------
             -------------
  404          // º¯Êý¼ò½é     ½âÎöGPSÊý¾Ý
  405          // ²ÎÊýËµÃ÷     void
  406          // ·µ»Ø²ÎÊý     uint8           0-½âÎö³É¹¦ 1-½âÎöÊ§°Ü ¿ÉÄÜÊý¾Ý°ü´íÎó
  407          // Ê¹ÓÃÊ¾Àý     gps_data_parse();
  408          // ±¸×¢ÐÅÏ¢
  409          //-------------------------------------------------------------------------------------------------------
             -------------
  410          uint8 gps_data_parse (void)
  411          {
  412   1          uint8 return_state = 0;
  413   1          uint8 check_buffer[5] = {'0', 'x', 0x00, 0x00, 0x00};
  414   1          uint8 bbc_xor_origin = 0;
  415   1          uint8 bbc_xor_calculation = 0;
  416   1          uint32 data_len = 0;
  417   1      
  418   1          do
  419   1          {
  420   2              if(GPS_STATE_RECEIVED == gps_rmc_state)
  421   2              {
  422   3                  gps_rmc_state = GPS_STATE_PARSING;
  423   3                  strncpy((char *)&check_buffer[2], strchr((const char *)gps_rmc_buffer, '*') + 1, 2);
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 8   

  424   3                  bbc_xor_origin = (uint8)func_str_to_hex((char *)check_buffer);
  425   3                  for(bbc_xor_calculation = gps_rmc_buffer[1], data_len = 2; '*' != gps_rmc_buffer[data_len]; d
             -ata_len ++)
  426   3                  {
  427   4                      bbc_xor_calculation ^= gps_rmc_buffer[data_len];
  428   4                  }
  429   3                  if(bbc_xor_calculation != bbc_xor_origin)
  430   3                  {
  431   4                      // Êý¾ÝÐ£ÑéÊ§°Ü
  432   4                      return_state = 1;
  433   4                      break;
  434   4                  }
  435   3      
  436   3                  gps_gnrmc_parse((char *)gps_rmc_buffer, &gps_tau1201);
  437   3              }
  438   2              gps_rmc_state = GPS_STATE_RECEIVING;
  439   2      
  440   2              if(GPS_STATE_RECEIVED == gps_gga_state)
  441   2              {
  442   3                  gps_gga_state = GPS_STATE_PARSING;
  443   3                  strncpy((char *)&check_buffer[2], strchr((const char *)gps_gga_buffer, '*') + 1, 2);
  444   3                  bbc_xor_origin = (uint8)func_str_to_hex((char *)check_buffer);
  445   3      
  446   3                  for(bbc_xor_calculation = gps_gga_buffer[1], data_len = 2; '*' != gps_gga_buffer[data_len]; d
             -ata_len ++)
  447   3                  {
  448   4                      bbc_xor_calculation ^= gps_gga_buffer[data_len];
  449   4                  }
  450   3                  if(bbc_xor_calculation != bbc_xor_origin)
  451   3                  {
  452   4                      // Êý¾ÝÐ£ÑéÊ§°Ü
  453   4                      return_state = 1;
  454   4                      break;
  455   4                  }
  456   3      
  457   3                  gps_gngga_parse((char *)gps_gga_buffer, &gps_tau1201);
  458   3              }
  459   2              gps_gga_state = GPS_STATE_RECEIVING;
  460   2      
  461   2          }while(0);
  462   1          return return_state;
  463   1      }
  464          
  465          
  466          //-------------------------------------------------------------------------------------------------------
             -------------
  467          // º¯Êý¼ò½é     GPS´®¿Ú»Øµ÷º¯Êý
  468          // ²ÎÊýËµÃ÷     void
  469          // ·µ»Ø²ÎÊý     void
  470          // Ê¹ÓÃÊ¾Àý     gps_uart_callback();
  471          // ±¸×¢ÐÅÏ¢     ´Ëº¯ÊýÐèÒªÔÚ´®¿Ú½ÓÊÕÖÐ¶ÏÄÚ½øÐÐµ÷ÓÃ
  472          //-------------------------------------------------------------------------------------------------------
             -------------
  473          void gps_uart_callback (uint8 uart_dat)
  474          {
  475   1          uint8 temp_gps[6];
  476   1          uint32 temp_length = 0;
  477   1      
  478   1          if(gps_tau1201_state)
  479   1          {
  480   2          fifo_write_buffer(&gps_tau1201_receiver_fifo, &uart_dat, 1);
  481   2              if('\n' == uart_dat)
  482   2              {
  483   3                  // ¶ÁÈ¡Ç°6¸öÊý¾Ý ÓÃÓÚÅÐ¶ÏÓï¾äÀàÐÍ
  484   3                  temp_length = 6;
  485   3                  fifo_read_buffer(&gps_tau1201_receiver_fifo, temp_gps, &temp_length, FIFO_READ_ONLY);
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 9   

  486   3      
  487   3                  // ¸ù¾Ý²»Í¬ÀàÐÍ½«Êý¾Ý¿½±´µ½²»Í¬µÄ»º³åÇø
  488   3                  if(0 == strncmp((char *)&temp_gps[3], "RMC", 3))
  489   3                  {
  490   4                      // Èç¹ûÃ»ÓÐÔÚ½âÎöÊý¾ÝÔò¸üÐÂ»º³åÇøµÄÊý¾Ý
  491   4                      if(GPS_STATE_PARSING != gps_rmc_state)
  492   4                      {
  493   5                          gps_rmc_state = GPS_STATE_RECEIVED;
  494   5                          temp_length = fifo_used(&gps_tau1201_receiver_fifo);
  495   5                          fifo_read_buffer(&gps_tau1201_receiver_fifo, gps_rmc_buffer, &temp_length, FIFO_READ_
             -AND_CLEAN);
  496   5                      }
  497   4                  }
  498   3                  else if(0 == strncmp((char *)&temp_gps[3], "GGA", 3))
  499   3                  {
  500   4                      // Èç¹ûÃ»ÓÐÔÚ½âÎöÊý¾ÝÔò¸üÐÂ»º³åÇøµÄÊý¾Ý
  501   4                      if(GPS_STATE_PARSING != gps_gga_state)
  502   4                      {
  503   5                          gps_gga_state = GPS_STATE_RECEIVED;
  504   5                          temp_length = fifo_used(&gps_tau1201_receiver_fifo);
  505   5                          fifo_read_buffer(&gps_tau1201_receiver_fifo, gps_gga_buffer, &temp_length, FIFO_READ_
             -AND_CLEAN);
  506   5                      }
  507   4                  }
  508   3      
  509   3                  // Í³Ò»½«FIFOÇå¿Õ
  510   3                  fifo_clear(&gps_tau1201_receiver_fifo);
  511   3      
  512   3                  gps_tau1201_flag = 1;
  513   3              }
  514   2          }
  515   1      }
  516          
  517          //-------------------------------------------------------------------------------------------------------
             -------------
  518          // º¯Êý¼ò½é     GPS³õÊ¼»¯
  519          // ²ÎÊýËµÃ÷     void
  520          // ·µ»Ø²ÎÊý     void
  521          // Ê¹ÓÃÊ¾Àý     gps_init();
  522          // ±¸×¢ÐÅÏ¢
  523          //-------------------------------------------------------------------------------------------------------
             -------------
  524          void gps_init (void)
  525          {
  526   1          const uint8 set_rate[]      = {0xF1, 0xD9, 0x06, 0x42, 0x14, 0x00, 0x00, 0x0A, 0x05, 0x00, 0x64, 0x00
             -, 0x00, 0x00, 0x60, 0xEA, 0x00, 0x00, 0xD0, 0x07, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0xB8, 0xED};
  527   1          const uint8 open_gga[]      = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x00, 0x01, 0xFB, 0x10};
  528   1          const uint8 open_rmc[]      = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x05, 0x01, 0x00, 0x1A};
  529   1      
  530   1          const uint8 close_gll[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x01, 0x00, 0xFB, 0x11};
  531   1          const uint8 close_gsa[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x02, 0x00, 0xFC, 0x13};
  532   1          const uint8 close_grs[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x03, 0x00, 0xFD, 0x15};
  533   1          const uint8 close_gsv[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x04, 0x00, 0xFE, 0x17};
  534   1          const uint8 close_vtg[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x06, 0x00, 0x00, 0x1B};
  535   1          const uint8 close_zda[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x07, 0x00, 0x01, 0x1D};
  536   1          const uint8 close_gst[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x08, 0x00, 0x02, 0x1F};
  537   1          const uint8 close_txt[]     = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x40, 0x00, 0x3A, 0x8F};
  538   1          const uint8 close_txt_ant[] = {0xF1, 0xD9, 0x06, 0x01, 0x03, 0x00, 0xF0, 0x20, 0x00, 0x1A, 0x4F};
  539   1      
  540   1          fifo_init(&gps_tau1201_receiver_fifo, FIFO_DATA_8BIT, gps_tau1201_receiver_buffer, GPS_TAU1201_BUFFER
             -_SIZE);
  541   1          delay_ms(500);                                                           // µÈ´ýGPSÆô¶¯ºó¿ªÊ¼³õÊ¼»¯
  542   1      
  543   1        uart_init(GPS_TAU1201_UART, GPS_TAU1201_RX, GPS_TAU1201_TX, 115200, GPS_TAU1201_TIMER_N); //³õÊ¼»¯´®¿Ú  
             -  
  544   1        
C251 COMPILER V5.60.0,  SEEKFREE_GPS_TAU1201                                               23/03/25  14:17:38  PAGE 10  

  545   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)set_rate, sizeof(set_rate));       // ÉèÖÃGPS¸üÐÂËÙÂÊÎª10hz È
             -ç¹û²»µ÷ÓÃ´ËÓï¾äÔòÄ¬ÈÏÎª1hz
  546   1          delay_ms(200);
  547   1      
  548   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)open_rmc, sizeof(open_rmc));       // ¿ªÆôrmcÓï¾ä
  549   1          delay_ms(50);
  550   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)open_gga, sizeof(open_gga));       // ¿ªÆôggaÓï¾ä
  551   1          delay_ms(50);
  552   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_gll, sizeof(close_gll));
  553   1          delay_ms(50);
  554   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_gsa, sizeof(close_gsa));
  555   1          delay_ms(50);
  556   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_grs, sizeof(close_grs));
  557   1          delay_ms(50);
  558   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_gsv, sizeof(close_gsv));
  559   1          delay_ms(50);
  560   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_vtg, sizeof(close_vtg));
  561   1          delay_ms(50);
  562   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_zda, sizeof(close_zda));
  563   1          delay_ms(50);
  564   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_gst, sizeof(close_gst));
  565   1          delay_ms(50);
  566   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_txt, sizeof(close_txt));
  567   1          delay_ms(50);
  568   1          uart_putbuff(GPS_TAU1201_UART, (uint8 *)close_txt_ant, sizeof(close_txt_ant));
  569   1          delay_ms(50);
  570   1      
  571   1          gps_tau1201_state = 1;
  572   1      
  573   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4961     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       956     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       184     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
