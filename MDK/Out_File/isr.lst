C251 COMPILER V5.60.0,  isr                                                                05/05/25  20:38:42  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\Out_File\isr.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\isr.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SP
                    -EED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree_libraries;..\seekfree_peripheral;.
                    -.\libraries) DEBUG PRINT(.\Out_File\isr.lst) TABS(2) OBJECT(.\Out_File\isr.obj) 

stmt  level    source

    1          // cursor-ignore-file
    2          ///******************************************************************************************************
             -***************
    3          // * COPYRIGHT NOTICE
    4          // * Copyright (c) 2020,ÈÄêÈ£ûÁßëÊäÄ
    5          // * All rights reserved.
    6          // * ÊäÄÊúØËÆ®ËÆ∫QQÁæ§Ôºö‰∏ÄÁæ§Ôºö179029047(Â∑≤Êª°)  ‰∫åÁæ§Ôºö244861897(Â∑≤Êª°)  ‰∏âÁæ§Ôºö824575535
    7          // *
    8          // * ‰ª•‰∏ãÊâÄÊúâÂÜÖÂÆπÁâàÊùÉÂùáÂ±ûÈÄêÈ£ûÁßëÊäÄÊâÄÊúâÔºåÊú™ÁªèÂÖÅËÆ∏‰∏çÂæóÁî®‰∫éÂïÜ‰∏öÁî®ÈÄîÔºå
    9          // * Ê¨¢ËøéÂêÑ‰Ωç‰ΩøÁî®Âπ∂‰º†Êí≠Êú¨Á®ãÂ∫èÔºå‰øÆÊîπÂÜÖÂÆπÊó∂ÂøÖÈ°ª‰øùÁïôÈÄêÈ£ûÁßëÊäÄÁöÑÁâàÊùÉÂ£∞Êòé„ÄÇ
   10          // *
   11          // * @file          isr
   12          // * @company       ÊàêÈÉΩÈÄêÈ£ûÁßëÊäÄÊúâÈôêÂÖ¨Âè∏
   13          // * @author        ÈÄêÈ£ûÁßëÊäÄ(QQ790875685)
   14          // * @version       Êü•ÁúãdocÂÜÖversionÊñá‰ª∂ ÁâàÊú¨ËØ¥Êòé
   15          // * @Software      MDK FOR C251 V5.60
   16          // * @Target core   STC32G12K128
   17          // * @Taobao        https://seekfree.taobao.com/
   18          // * @date          2020-4-14
   19          // ******************************************************************************************************
             -**************/
   20          #include "headfile.h"
   21          #include "encoder.h"
   22          #include "filter.h"
   23          #include "motor.h"
   24          #include "pid.h"
   25          #include "isr.h"
   26          #include "key.h"
   27          #include "electromagnetic_tracking.h"
   28          
   29          
   30          //void  INT0_Isr()  interrupt 0;
   31          //void  TM0_Isr()   interrupt 1;
   32          //void  INT1_Isr()  interrupt 2;
   33          //void  TM1_Isr()   interrupt 3;
   34          //void  UART1_Isr() interrupt 4;
   35          //void  ADC_Isr()   interrupt 5;
   36          //void  LVD_Isr()   interrupt 6;
   37          //void  PCA_Isr()   interrupt 7;
   38          //void  UART2_Isr() interrupt 8;
   39          //void  SPI_Isr()   interrupt 9;
   40          //void  INT2_Isr()  interrupt 10;
   41          //void  INT3_Isr()  interrupt 11;
   42          //void  TM2_Isr()   interrupt 12;
   43          //void  INT4_Isr()  interrupt 16;
   44          //void  UART3_Isr() interrupt 17;
   45          //void  UART4_Isr() interrupt 18;
   46          //void  TM3_Isr()   interrupt 19;
   47          //void  TM4_Isr()   interrupt 20;
   48          //void  CMP_Isr()   interrupt 21;
   49          //void  I2C_Isr()   interrupt 24;
   50          //void  USB_Isr()   interrupt 25;
   51          //void  PWM1_Isr()  interrupt 26;
   52          //void  PWM2_Isr()  interrupt 27;
   53          
   54          // ÂáΩÊï∞ÂâçÁΩÆÂ£∞Êòé
   55          void uart4_interrupt_callback(void);
C251 COMPILER V5.60.0,  isr                                                                05/05/25  20:38:42  PAGE 2   

   56          
   57          // ÂÖ®Â±ÄÂèòÈáèÂÆö‰πâ
   58          float left_pid = 0, right_pid = 0;               // ÈÄüÂ∫¶ÁéØpidÁöÑÂ¢ûÈáèÔºåËøòÈúÄËΩ¨ÂåñÂÜçËµãÁªôÁîµÊú∫
   59          int g_DutyLeft = 0, g_DutyRight = 0;         // ÊúÄÂêéÁúüÊ≠£Ë¶ÅÁªôÁîµÊú∫ÁöÑPWMÂÄº
   60          float Gyro_Z = 0, filtered_GyroZ = 0;            // ÈôÄËû∫‰ª™ËßíÈÄüÂ∫¶ÁöÑÂéüÂßãÂÄºÂíåÂç°Â∞îÊõºÊª§Ê≥¢‰πãÂê
             -éÁöÑÂÄº
   61          float turn_pid = 0;
   62          int g_SpeedPoint = 30;
   63          int g_LeftPoint = 0;                             // Â∑¶ËΩÆÁõÆÊ†áÈÄüÂ∫¶                  
   64          int g_RightPoint = 0;                            // Âè≥ËΩÆÁõÆÊ†áÈÄüÂ∫¶             
   65          int count = 0, flag = 0;
   66          int turn_count = 0;
   67          
   68          int k = 0;
   69          int turnflag = 0;
   70          uint8_t startKeyFlag = 0, uartSendFlag = 1;
   71          
   72          //UART1‰∏≠Êñ≠
   73          void UART1_Isr() interrupt 4
   74          {
   75   1      //    uint8 res;
   76   1      //  static uint8 dwon_count;
   77   1          if(UART1_GET_TX_FLAG)
   78   1          {
   79   2              UART1_CLEAR_TX_FLAG;
   80   2              busy[1] = 0;
   81   2          }
   82   1          if(UART1_GET_RX_FLAG)
   83   1          {
   84   2              UART1_CLEAR_RX_FLAG;
   85   2      //        res = SBUF;
   86   2      //        //Á®ãÂ∫èËá™Âä®‰∏ãËΩΩ
   87   2      //        if(res == 0x7F)
   88   2      //        {
   89   2      //            if(dwon_count++ > 20)
   90   2      //                IAP_CONTR = 0x60;
   91   2      //        }
   92   2      //        else
   93   2      //        {
   94   2      //            dwon_count = 0;
   95   2      //        }
   96   2          }
   97   1      }
   98          
   99          
  100          
  101          //UART2‰∏≠Êñ≠
  102          void UART2_Isr() interrupt 8
  103          {
  104   1          if(UART2_GET_TX_FLAG)
  105   1        {
  106   2              UART2_CLEAR_TX_FLAG;
  107   2          busy[2] = 0;
  108   2        }
  109   1          if(UART2_GET_RX_FLAG)
  110   1        {
  111   2              UART2_CLEAR_RX_FLAG;
  112   2          //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS2BUF
  113   2      
  114   2      
  115   2        }
  116   1      }
  117          
  118          
  119          //UART3‰∏≠Êñ≠
  120          void UART3_Isr() interrupt 17
C251 COMPILER V5.60.0,  isr                                                                05/05/25  20:38:42  PAGE 3   

  121          {
  122   1          if(UART3_GET_TX_FLAG)
  123   1        {
  124   2              UART3_CLEAR_TX_FLAG;
  125   2          busy[3] = 0;
  126   2        }
  127   1          if(UART3_GET_RX_FLAG)
  128   1        {
  129   2              UART3_CLEAR_RX_FLAG;
  130   2          //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS3BUF
  131   2      
  132   2        }
  133   1      }
  134          
  135          
  136          
  137          //UART4‰∏≠Êñ≠
  138          void UART4_Isr() interrupt 18
  139          {
  140   1          if(UART4_GET_TX_FLAG)
  141   1        {
  142   2              UART4_CLEAR_TX_FLAG;
  143   2          busy[4] = 0;
  144   2        }
  145   1          if(UART4_GET_RX_FLAG)
  146   1        {
  147   2              UART4_CLEAR_RX_FLAG;
  148   2          //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS4BUF;
  149   2      
  150   2          g_RxDat = S4BUF;
  151   2          g_RxData[g_RxPointer++] = g_RxDat;
  152   2        }
  153   1      }
  154          
  155          
  156          
  157          //Â§ñÈÉ®‰∏≠Êñ≠0
  158          void INT0_Isr() interrupt 0
  159          {
  160   1      
  161   1      }
  162          
  163          
  164          
  165          //Â§ñÈÉ®‰∏≠Êñ≠1
  166          void INT1_Isr() interrupt 2
  167          {
  168   1      
  169   1      }
  170          
  171          
  172          
  173          //Â§ñÈÉ®‰∏≠Êñ≠2
  174          void INT2_Isr() interrupt 10
  175          {
  176   1        INT2_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  177   1        
  178   1      }
  179          
  180          
  181          
  182          //Â§ñÈÉ®‰∏≠Êñ≠3
  183          void INT3_Isr() interrupt 11
  184          {
  185   1        INT3_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  186   1        
C251 COMPILER V5.60.0,  isr                                                                05/05/25  20:38:42  PAGE 4   

  187   1      }
  188          
  189          
  190          
  191          //Â§ñÈÉ®‰∏≠Êñ≠4
  192          void INT4_Isr() interrupt 16
  193          {
  194   1        INT4_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  195   1        
  196   1      }
  197          
  198          
  199          
  200          //ÂÆöÊó∂Âô®0‰∏≠Êñ≠
  201          void TM0_Isr() interrupt 1
  202          {
  203   1        
  204   1      }
  205          
  206          
  207          
  208          //ÂÆöÊó∂Âô®1‰∏≠Êñ≠
  209          void TM1_Isr() interrupt 3
  210          {
  211   1        int i = 0;
  212   1        
  213   1        key[0].state = P70;
  214   1        key[1].state = P71;
  215   1        key[2].state = P72;
  216   1        key[3].state = P73;
  217   1        
  218   1        for (i = 0; i < 4; i++)
  219   1        {
  220   2          switch (key[i].step)
  221   2          {
  222   3            case 0:
  223   3            {
  224   4              if (key[i].state == 0)
  225   4              {
  226   5                key[i].step = 1;
  227   5              }
  228   4            }
  229   3            break;
  230   3            
  231   3            case 1:
  232   3            {
  233   4              if (key[i].state == 0)
  234   4              {
  235   5                key[i].step = 2;
  236   5                key[i].flag = 1;
  237   5              }
  238   4              else
  239   4              {
  240   5                key[i].step = 0;
  241   5              }
  242   4            }
  243   3            break;
  244   3            
  245   3            case 2:
  246   3            {
  247   4              if (key[i].state == 1)
  248   4              {
  249   5                key[i].step = 0;
  250   5              }
  251   4            }
  252   3            break;
C251 COMPILER V5.60.0,  isr                                                                05/05/25  20:38:42  PAGE 5   

  253   3          }
  254   2        }
  255   1      }
  256          
  257          
  258          
  259          //ÂÆöÊó∂Âô®2‰∏≠Êñ≠
  260          void TM2_Isr() interrupt 12
  261          {
  262   1        TIM2_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  263   1        
  264   1        /* ÊôÆÈÄöÂÆöÊó∂ÂäüËÉΩÔºåÂ§áÁî® */
  265   1        count++;
  266   1        if (count >= 100)
  267   1        {
  268   2          flag = 1;
  269   2          count = 0;
  270   2        }
  271   1        
  272   1        
  273   1        //ËØªÂèñÂπ∂Ê∏ÖÈô§ÁºñÁ†ÅÂô®ÁöÑÂÄº
  274   1        g_EncoderLeft = get_left_encoder();
  275   1        g_EncoderRight = get_right_encoder();
  276   1        
  277   1        /*
  278   1          ËØªÂèñËßíÈÄüÂ∫¶Âπ∂ËΩ¨Âåñ‰∏∫ÂÆûÈôÖÁâ©ÁêÜÊï∞ÊçÆ
  279   1          ÂΩìÁ™ÅÁÑ∂Â∑¶ËΩ¨ÔºåGyro_Z‰∏∫Ê≠£ÂÄºÔºõÁ™ÅÁÑ∂Âè≥ËΩ¨ÔºåGyro_Z‰∏∫Ë¥üÂÄº
  280   1        */
  281   1      //  imu963ra_get_gyro();
  282   1      //  Gyro_Z = imu963ra_gyro_transition(imu963ra_gyro_z);
  283   1        
  284   1        //ÂØπGyro_ZËøõË°åÂç°Â∞îÊõºÊª§Ê≥¢
  285   1      //  filtered_GyroZ = Kalman_Update(&imu693_kf, Gyro_Z);
  286   1      
  287   1        if (startKeyFlag == 1)
  288   1        {
  289   2          /* 5msÁÆó‰∏ÄÊ¨°ÂÜÖÁéØÔºå15msÁÆó‰∏ÄÊ¨°Â§ñÁéØ */
  290   2          turn_count++;
  291   2          if (turn_count >= 3)
  292   2          {
  293   3            turn_pid = pid_poisitional_normal(&TurnPID, position);
  294   3            turn_count = 0;
  295   3          }
  296   2        
  297   2        
  298   2        //Êõ¥Êñ∞Âç°Â∞îÊõºÊª§Ê≥¢ÁöÑÂÄº
  299   2      //  Kalman_Predict(&imu693_kf, turn_pid);
  300   2      
  301   2          if(turn_pid >= 0) // Â∑¶ËΩ¨
  302   2          {
  303   3            k = turn_pid * 0.01; // Áº©ÊîæËá≥ 0.0 ~ 1.0
  304   3            g_LeftPoint = g_SpeedPoint * (1 - k);
  305   3            g_RightPoint = g_SpeedPoint * (1 + k * 0.5); // Âä†Â∞ëÂáèÂ§ö
  306   3          }
  307   2          else // Âè≥ËΩ¨
  308   2          {
  309   3            k = -turn_pid * 0.01; // ÂèñÁõ∏ÂèçÊï∞Âπ∂Áº©ÊîæËá≥ 0.0 ~ 1.0
  310   3            g_LeftPoint = g_SpeedPoint * (1 + k * 0.5); // Âä†Â∞ëÂáèÂ§ö
  311   3            g_RightPoint = g_SpeedPoint * (1 - k);
  312   3          }
  313   2      
  314   2          //ËÆ°ÁÆóÈÄüÂ∫¶ÁéØpid
  315   2          left_pid = pid_increment_feedforward(&LeftPID, g_EncoderLeft, g_LeftPoint);
  316   2          right_pid = pid_increment_feedforward(&RightPID, g_EncoderRight, g_RightPoint);
  317   2          
  318   2          //ËΩ¨int
C251 COMPILER V5.60.0,  isr                                                                05/05/25  20:38:42  PAGE 6   

  319   2          g_DutyLeft = (int)left_pid;
  320   2          g_DutyRight = (int)right_pid;
  321   2          
  322   2          
  323   2          if (protection_flag == 0)
  324   2          {
  325   3            set_motor_pwm(g_DutyLeft, g_DutyRight);
  326   3          }
  327   2          else
  328   2          {
  329   3            set_motor_pwm(0, 0);
  330   3          }
  331   2        }
  332   1        
  333   1        
  334   1      }
  335          
  336          
  337          
  338          //ÂÆöÊó∂Âô®3‰∏≠Êñ≠
  339          void TM3_Isr() interrupt 19
  340          {
  341   1        TIM3_CLEAR_FLAG; //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  342   1        
  343   1      }
  344          
  345          
  346          
  347          //ÂÆöÊó∂Âô®4‰∏≠Êñ≠
  348          void TM4_Isr() interrupt 20
  349          {
  350   1        TIM4_CLEAR_FLAG; //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  351   1      
  352   1      
  353   1      }
  354          
  355          
  356          //void  INT0_Isr()  interrupt 0;
  357          //void  TM0_Isr()   interrupt 1;
  358          //void  INT1_Isr()  interrupt 2;
  359          //void  TM1_Isr()   interrupt 3;
  360          //void  UART1_Isr() interrupt 4;
  361          //void  ADC_Isr()   interrupt 5;
  362          //void  LVD_Isr()   interrupt 6;
  363          //void  PCA_Isr()   interrupt 7;
  364          //void  UART2_Isr() interrupt 8;
  365          //void  SPI_Isr()   interrupt 9;
  366          //void  INT2_Isr()  interrupt 10;
  367          //void  INT3_Isr()  interrupt 11;
  368          //void  TM2_Isr()   interrupt 12;
  369          //void  INT4_Isr()  interrupt 16;
  370          //void  UART3_Isr() interrupt 17;
  371          //void  UART4_Isr() interrupt 18;
  372          //void  TM3_Isr()   interrupt 19;
  373          //void  TM4_Isr()   interrupt 20;
  374          //void  CMP_Isr()   interrupt 21;
  375          //void  I2C_Isr()   interrupt 24;
  376          //void  USB_Isr()   interrupt 25;
  377          //void  PWM1_Isr()  interrupt 26;
  378          //void  PWM2_Isr()  interrupt 27;


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       991     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
C251 COMPILER V5.60.0,  isr                                                                05/05/25  20:38:42  PAGE 7   

  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        44     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       110     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
