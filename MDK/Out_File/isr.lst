C251 COMPILER V5.60.0,  isr                                                                01/04/25  10:50:42  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\Out_File\isr.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\isr.c XSMALL INTR2 FLOAT64 WARNINGLEVEL(3)
                    - OPTIMIZE(0,SPEED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree_libraries;..\seekfre
                    -e_peripheral;..\libraries) DEBUG PRINT(.\Out_File\isr.lst) TABS(2) OBJECT(.\Out_File\isr.obj) 

stmt  level    source

    1          ///******************************************************************************************************
             -***************
    2          // * COPYRIGHT NOTICE
    3          // * Copyright (c) 2020,é€é£ç§‘æŠ€
    4          // * All rights reserved.
    5          // * æŠ€æœ¯è®¨è®ºQQç¾¤ï¼šä¸€ç¾¤ï¼š179029047(å·²æ»¡)  äºŒç¾¤ï¼š244861897(å·²æ»¡)  ä¸‰ç¾¤ï¼š824575535
    6          // *
    7          // * ä»¥ä¸‹æ‰€æœ‰å†…å®¹ç‰ˆæƒå‡å±é€é£ç§‘æŠ€æ‰€æœ‰ï¼Œæœªç»å…è®¸ä¸å¾—ç”¨äºå•†ä¸šç”¨é€”ï¼Œ
    8          // * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åºï¼Œä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ã€‚
    9          // *
   10          // * @file          isr
   11          // * @company       æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   12          // * @author        é€é£ç§‘æŠ€(QQ790875685)
   13          // * @version       æŸ¥çœ‹docå†…versionæ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   14          // * @Software      MDK FOR C251 V5.60
   15          // * @Target core   STC32G12K128
   16          // * @Taobao        https://seekfree.taobao.com/
   17          // * @date          2020-4-14
   18          // ******************************************************************************************************
             -**************/
   19          #include "headfile.h"
   20          #include "encoder.h"
   21          #include "filter.h"
   22          #include "motor.h"
   23          #include "pid.h"
   24          #include "isr.h"
   25          
   26          //UART1ä¸­æ–­
   27          void UART1_Isr() interrupt 4
   28          {
   29   1      //    uint8 res;
   30   1      //  static uint8 dwon_count;
   31   1          if(UART1_GET_TX_FLAG)
   32   1          {
   33   2              UART1_CLEAR_TX_FLAG;
   34   2              busy[1] = 0;
   35   2          }
   36   1          if(UART1_GET_RX_FLAG)
   37   1          {
   38   2              UART1_CLEAR_RX_FLAG;
   39   2      //        res = SBUF;
   40   2      //        //ç¨‹åºè‡ªåŠ¨ä¸‹è½½
   41   2      //        if(res == 0x7F)
   42   2      //        {
   43   2      //            if(dwon_count++ > 20)
   44   2      //                IAP_CONTR = 0x60;
   45   2      //        }
   46   2      //        else
   47   2      //        {
   48   2      //            dwon_count = 0;
   49   2      //        }
   50   2          }
   51   1      }
   52          
   53          
   54          
   55          //UART2ä¸­æ–­
C251 COMPILER V5.60.0,  isr                                                                01/04/25  10:50:42  PAGE 2   

   56          void UART2_Isr() interrupt 8
   57          {
   58   1          if(UART2_GET_TX_FLAG)
   59   1        {
   60   2              UART2_CLEAR_TX_FLAG;
   61   2          busy[2] = 0;
   62   2        }
   63   1          if(UART2_GET_RX_FLAG)
   64   1        {
   65   2              UART2_CLEAR_RX_FLAG;
   66   2          //æ¥æ”¶æ•°æ®å¯„å­˜å™¨ä¸ºï¼šS2BUF
   67   2      
   68   2      
   69   2        }
   70   1      }
   71          
   72          
   73          //UART3ä¸­æ–­
   74          void UART3_Isr() interrupt 17
   75          {
   76   1          if(UART3_GET_TX_FLAG)
   77   1        {
   78   2              UART3_CLEAR_TX_FLAG;
   79   2          busy[3] = 0;
   80   2        }
   81   1          if(UART3_GET_RX_FLAG)
   82   1        {
   83   2              UART3_CLEAR_RX_FLAG;
   84   2          //æ¥æ”¶æ•°æ®å¯„å­˜å™¨ä¸ºï¼šS3BUF
   85   2      
   86   2        }
   87   1      }
   88          
   89          
   90          
   91          //UART4ä¸­æ–­
   92          void UART4_Isr() interrupt 18
   93          {
   94   1          if(UART4_GET_TX_FLAG)
   95   1        {
   96   2              UART4_CLEAR_TX_FLAG;
   97   2          busy[4] = 0;
   98   2        }
   99   1          if(UART4_GET_RX_FLAG)
  100   1        {
  101   2              UART4_CLEAR_RX_FLAG;
  102   2          //æ¥æ”¶æ•°æ®å¯„å­˜å™¨ä¸ºï¼šS4BUF;
  103   2      
  104   2          g_RxDat = S4BUF;
  105   2          g_RxData[g_RxPointer++] = g_RxDat;
  106   2        }
  107   1      }
  108          
  109          
  110          
  111          //å¤–éƒ¨ä¸­æ–­0
  112          void INT0_Isr() interrupt 0
  113          {
  114   1      
  115   1      }
  116          
  117          
  118          
  119          //å¤–éƒ¨ä¸­æ–­1
  120          void INT1_Isr() interrupt 2
  121          {
C251 COMPILER V5.60.0,  isr                                                                01/04/25  10:50:42  PAGE 3   

  122   1      
  123   1      }
  124          
  125          
  126          
  127          //å¤–éƒ¨ä¸­æ–­2
  128          void INT2_Isr() interrupt 10
  129          {
  130   1        INT2_CLEAR_FLAG;  //æ¸…é™¤ä¸­æ–­æ ‡å¿—
  131   1        
  132   1      }
  133          
  134          
  135          
  136          //å¤–éƒ¨ä¸­æ–­3
  137          void INT3_Isr() interrupt 11
  138          {
  139   1        INT3_CLEAR_FLAG;  //æ¸…é™¤ä¸­æ–­æ ‡å¿—
  140   1        
  141   1      }
  142          
  143          
  144          
  145          //å¤–éƒ¨ä¸­æ–­4
  146          void INT4_Isr() interrupt 16
  147          {
  148   1        INT4_CLEAR_FLAG;  //æ¸…é™¤ä¸­æ–­æ ‡å¿—
  149   1        
  150   1      }
  151          
  152          
  153          
  154          //å®šæ—¶å™¨0ä¸­æ–­
  155          void TM0_Isr() interrupt 1
  156          {
  157   1        
  158   1      }
  159          
  160          
  161          
  162          //å®šæ—¶å™¨1ä¸­æ–­
  163          void TM1_Isr() interrupt 3
  164          {
  165   1      
  166   1        
  167   1      }
  168          
  169          
  170          float left_pid = 0, right_pid = 0;               //é€Ÿåº¦ç¯pidçš„å¢é‡ï¼Œè¿˜éœ€è½¬åŒ–å†èµ‹ç»™ç”µæœº
  171          float pidtopwm_left = 0, pidtopwm_right = 0;     //é€Ÿåº¦ç¯pidçš„è½¬åŒ–å€¼
  172          int g_DutyLeft = 0, g_DutyRight = 0;             //æœ€åçœŸæ­£è¦ç»™ç”µæœºçš„PWMå€¼
  173          
  174          float imu693_pid = 0;                            //é™€èºä»ªpidçš„å€¼
  175          float Gyro_Z = 0, filtered_GyroZ = 0;            //é™€èºä»ªè§’é€Ÿåº¦çš„åŸå§‹å€¼å’Œå¡å°”æ›¼æ»¤æ³¢ä¹‹å
             -çš„å€¼
  176          
  177          int g_LeftPoint = 50;                            //å·¦è½®ç›®æ ‡é€Ÿåº¦                  
  178          int g_RightPoint = 50;                           //å³è½®ç›®æ ‡é€Ÿåº¦       
  179          float g_IMU693Point = 0.0;                       //é™€èºä»ªç›®æ ‡è§’é€Ÿåº¦       
  180          
  181          int count = 0, flag = 0;
  182          
  183          
  184          //å®šæ—¶å™¨2ä¸­æ–­
  185          void TM2_Isr() interrupt 12
  186          {
C251 COMPILER V5.60.0,  isr                                                                01/04/25  10:50:42  PAGE 4   

  187   1        TIM2_CLEAR_FLAG;  //æ¸…é™¤ä¸­æ–­æ ‡å¿—
  188   1        
  189   1        count++;
  190   1        if (count >= 300)
  191   1        {
  192   2          flag = 1;
  193   2          count = 0;
  194   2        }
  195   1        
  196   1        //è¯»å–å¹¶æ¸…é™¤ç¼–ç å™¨çš„å€¼
  197   1        g_EncoderLeft = get_left_encoder();
  198   1        g_EncoderRight = get_right_encoder();
  199   1        
  200   1        /*
  201   1          è¯»å–è§’é€Ÿåº¦å¹¶è½¬åŒ–ä¸ºå®é™…ç‰©ç†æ•°æ®
  202   1          å½“çªç„¶å·¦è½¬ï¼ŒGyro_Zä¸ºæ­£å€¼ï¼›çªç„¶å³è½¬ï¼ŒGyro_Zä¸ºè´Ÿå€¼
  203   1        */
  204   1        // imu963ra_get_gyro();
  205   1        // Gyro_Z = imu963ra_gyro_transition(imu963ra_gyro_z);
  206   1        
  207   1        // //å¯¹Gyro_Zè¿›è¡Œå¡å°”æ›¼æ»¤æ³¢
  208   1        // filtered_GyroZ = Kalman_Update(&imu693_kf, Gyro_Z);
  209   1        
  210   1        // //è®¡ç®—é™€èºä»ªè§’é€Ÿåº¦pid
  211   1        // imu693_pid = pid_poisitional(&IMU693PID, filtered_GyroZ, g_IMU693Point);
  212   1        
  213   1        // //æ›´æ–°å¡å°”æ›¼æ»¤æ³¢çš„å€¼
  214   1        // Kalman_Predict(&imu693_kf, imu693_pid);
  215   1        
  216   1        // //è®¡ç®—é€Ÿåº¦ç¯pid
  217   1        // left_pid = pid_increment(&LeftPID, g_EncoderLeft, g_LeftPoint);
  218   1        // right_pid = pid_increment(&RightPID, g_EncoderRight, g_RightPoint);
  219   1        
  220   1        // /*
  221   1        //  æŠŠé€Ÿåº¦ç¯pidçš„å€¼è½¬åŒ–æˆPWMçš„å¢å€¼
  222   1        //  å› ä¸ºleft_pidå’Œright_pidçš„å€¼å¾ˆå°ï¼Œå¤§æ¦‚åœ¨é›¶ç‚¹å‡ å·¦å³ï¼Œæ‰€ä»¥æˆ‘å°±æŠŠä»–æ”¾å¤§äº†ä¸€ç‚
             -¹
  223   1        //  æ‰€ä»¥ä¹Ÿä¸æ˜¯ä¸¥æ ¼çš„è½¬åŒ–æˆpwmçš„æ•°é‡çº§
  224   1        // */
  225   1        // pidtopwm_left = 40.0 * left_pid;
  226   1        // pidtopwm_right = 40.0 * right_pid;
  227   1        
  228   1        // //å¹¶çº§pidç´¯åŠ 
  229   1        // g_DutyLeft += pidtopwm_left - imu693_pid;
  230   1        // g_DutyRight += pidtopwm_right + imu693_pid;
  231   1        
  232   1        // set_motor_pwm(g_DutyLeft, g_DutyRight);
  233   1      
  234   1      }
  235          
  236          
  237          
  238          //å®šæ—¶å™¨3ä¸­æ–­
  239          void TM3_Isr() interrupt 19
  240          {
  241   1        TIM3_CLEAR_FLAG; //æ¸…é™¤ä¸­æ–­æ ‡å¿—
  242   1        
  243   1      }
  244          
  245          
  246          
  247          //å®šæ—¶å™¨4ä¸­æ–­
  248          void TM4_Isr() interrupt 20
  249          {
  250   1        TIM4_CLEAR_FLAG; //æ¸…é™¤ä¸­æ–­æ ‡å¿—
  251   1      
C251 COMPILER V5.60.0,  isr                                                                01/04/25  10:50:42  PAGE 5   

  252   1      
  253   1      }
  254          
  255          
  256          //void  INT0_Isr()  interrupt 0;
  257          //void  TM0_Isr()   interrupt 1;
  258          //void  INT1_Isr()  interrupt 2;
  259          //void  TM1_Isr()   interrupt 3;
  260          //void  UART1_Isr() interrupt 4;
  261          //void  ADC_Isr()   interrupt 5;
  262          //void  LVD_Isr()   interrupt 6;
  263          //void  PCA_Isr()   interrupt 7;
  264          //void  UART2_Isr() interrupt 8;
  265          //void  SPI_Isr()   interrupt 9;
  266          //void  INT2_Isr()  interrupt 10;
  267          //void  INT3_Isr()  interrupt 11;
  268          //void  TM2_Isr()   interrupt 12;
  269          //void  INT4_Isr()  interrupt 16;
  270          //void  UART3_Isr() interrupt 17;
  271          //void  UART4_Isr() interrupt 18;
  272          //void  TM3_Isr()   interrupt 19;
  273          //void  TM4_Isr()   interrupt 20;
  274          //void  CMP_Isr()   interrupt 21;
  275          //void  I2C_Isr()   interrupt 24;
  276          //void  USB_Isr()   interrupt 25;
  277          //void  PWM1_Isr()  interrupt 26;
  278          //void  PWM2_Isr()  interrupt 27;


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       346     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        44     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       100     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
