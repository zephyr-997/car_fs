C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\Out_File\isr.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\isr.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SP
                    -EED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree_libraries;..\seekfree_peripheral;.
                    -.\libraries) DEBUG PRINT(.\Out_File\isr.lst) TABS(2) OBJECT(.\Out_File\isr.obj) 

stmt  level    source

    1          // cursor-ignore-file
    2          ///******************************************************************************************************
             -***************
    3          // * COPYRIGHT NOTICE
    4          // * Copyright (c) 2020,ÈÄêÈ£ûÁßëÊäÄ
    5          // * All rights reserved.
    6          // * ÊäÄÊúØËÆ®ËÆ∫QQÁæ§Ôºö‰∏ÄÁæ§Ôºö179029047(Â∑≤Êª°)  ‰∫åÁæ§Ôºö244861897(Â∑≤Êª°)  ‰∏âÁæ§Ôºö824575535
    7          // *
    8          // * ‰ª•‰∏ãÊâÄÊúâÂÜÖÂÆπÁâàÊùÉÂùáÂ±ûÈÄêÈ£ûÁßëÊäÄÊâÄÊúâÔºåÊú™ÁªèÂÖÅËÆ∏‰∏çÂæóÁî®‰∫éÂïÜ‰∏öÁî®ÈÄîÔºå
    9          // * Ê¨¢ËøéÂêÑ‰Ωç‰ΩøÁî®Âπ∂‰º†Êí≠Êú¨Á®ãÂ∫èÔºå‰øÆÊîπÂÜÖÂÆπÊó∂ÂøÖÈ°ª‰øùÁïôÈÄêÈ£ûÁßëÊäÄÁöÑÁâàÊùÉÂ£∞Êòé„ÄÇ
   10          // *
   11          // * @file          isr
   12          // * @company       ÊàêÈÉΩÈÄêÈ£ûÁßëÊäÄÊúâÈôêÂÖ¨Âè∏
   13          // * @author        ÈÄêÈ£ûÁßëÊäÄ(QQ790875685)
   14          // * @version       Êü•ÁúãdocÂÜÖversionÊñá‰ª∂ ÁâàÊú¨ËØ¥Êòé
   15          // * @Software      MDK FOR C251 V5.60
   16          // * @Target core   STC32G12K128
   17          // * @Taobao        https://seekfree.taobao.com/
   18          // * @date          2020-4-14
   19          // ******************************************************************************************************
             -**************/
   20          #include "headfile.h"
   21          #include "encoder.h"
   22          #include "filter.h"
   23          #include "motor.h"
   24          #include "pid.h"
   25          #include "isr.h"
   26          #include "key.h"
   27          #include "electromagnetic_tracking.h"
   28          
   29          //void  INT0_Isr()  interrupt 0;
   30          //void  TM0_Isr()   interrupt 1;
   31          //void  INT1_Isr()  interrupt 2;
   32          //void  TM1_Isr()   interrupt 3;
   33          //void  UART1_Isr() interrupt 4;
   34          //void  ADC_Isr()   interrupt 5;
   35          //void  LVD_Isr()   interrupt 6;
   36          //void  PCA_Isr()   interrupt 7;
   37          //void  UART2_Isr() interrupt 8;
   38          //void  SPI_Isr()   interrupt 9;
   39          //void  INT2_Isr()  interrupt 10;
   40          //void  INT3_Isr()  interrupt 11;
   41          //void  TM2_Isr()   interrupt 12;
   42          //void  INT4_Isr()  interrupt 16;
   43          //void  UART3_Isr() interrupt 17;
   44          //void  UART4_Isr() interrupt 18;
   45          //void  TM3_Isr()   interrupt 19;
   46          //void  TM4_Isr()   interrupt 20;
   47          //void  CMP_Isr()   interrupt 21;
   48          //void  I2C_Isr()   interrupt 24;
   49          //void  USB_Isr()   interrupt 25;
   50          //void  PWM1_Isr()  interrupt 26;
   51          //void  PWM2_Isr()  interrupt 27;
   52          
   53          // ÂáΩÊï∞ÂâçÁΩÆÂ£∞Êòé
   54          void uart4_interrupt_callback(void);
   55          
C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 2   

   56          // ÂÖ®Â±ÄÂèòÈáèÂÆö‰πâ
   57          float left_pid = 0, right_pid = 0;               // ÈÄüÂ∫¶ÁéØpidÁöÑÂ¢ûÈáèÔºåËøòÈúÄËΩ¨ÂåñÂÜçËµãÁªôÁîµÊú∫
   58          int32_t g_DutyLeft = 0, g_DutyRight = 0;         // ÊúÄÂêéÁúüÊ≠£Ë¶ÅÁªôÁîµÊú∫ÁöÑPWMÂÄº
   59          float Gyro_Z = 0, filtered_GyroZ = 0;            // ÈôÄËû∫‰ª™ËßíÈÄüÂ∫¶ÁöÑÂéüÂßãÂÄºÂíåÂç°Â∞îÊõºÊª§Ê≥¢‰πãÂê
             -éÁöÑÂÄº
   60          float turn_pid = 0;
   61          int g_SpeedPoint = 30;
   62          int g_LeftPoint = 0;                             // Â∑¶ËΩÆÁõÆÊ†áÈÄüÂ∫¶                  
   63          int g_RightPoint = 0;                            // Âè≥ËΩÆÁõÆÊ†áÈÄüÂ∫¶             
   64          int count = 0, flag = 0;
   65          int turn_count = 0;
   66          
   67          float k = 0;
   68          int turnflag = 0;
   69          uint8_t startKeyFlag = 0, uartSendFlag = 1;
   70          
   71          // ËúÇÈ∏£Âô®ÊéßÂà∂Áõ∏ÂÖ≥ÂèòÈáè
   72          uint8_t beep_flag = 0;          // ËúÇÈ∏£Âô®ÂºÄÂêØÊ†áÂøóÔºå1Ë°®Á§∫ÂºÄÂêØ
   73          uint16_t beep_count = 0;        // ËúÇÈ∏£Âô®ËÆ°Êó∂ËÆ°Êï∞Âô®
   74          uint8_t track_ten_cnt = 0;    //Âá∫ÂÖ•ÁéØÈáçÂ§çÂà§ÂÆöËÆ°Êó∂Âô®
   75          
   76          
   77          extern uint8 track_ten_flag;
   78          extern uint8 ten_change_flag;
   79          
   80          //UART1‰∏≠Êñ≠
   81          void UART1_Isr() interrupt 4
   82          {
   83   1      //    uint8 res;
   84   1      //  static uint8 dwon_count;
   85   1          if(UART1_GET_TX_FLAG)
   86   1          {
   87   2              UART1_CLEAR_TX_FLAG;
   88   2              busy[1] = 0;
   89   2          }
   90   1          if(UART1_GET_RX_FLAG)
   91   1          {
   92   2              UART1_CLEAR_RX_FLAG;
   93   2      //        res = SBUF;
   94   2      //        //Á®ãÂ∫èËá™Âä®‰∏ãËΩΩ
   95   2      //        if(res == 0x7F)
   96   2      //        {
   97   2      //            if(dwon_count++ > 20)
   98   2      //                IAP_CONTR = 0x60;
   99   2      //        }
  100   2      //        else
  101   2      //        {
  102   2      //            dwon_count = 0;
  103   2      //        }
  104   2          }
  105   1      }
  106          
  107          
  108          
  109          //UART2‰∏≠Êñ≠
  110          void UART2_Isr() interrupt 8
  111          {
  112   1          if(UART2_GET_TX_FLAG)
  113   1        {
  114   2              UART2_CLEAR_TX_FLAG;
  115   2          busy[2] = 0;
  116   2        }
  117   1          if(UART2_GET_RX_FLAG)
  118   1        {
  119   2              UART2_CLEAR_RX_FLAG;
  120   2          //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS2BUF
C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 3   

  121   2      
  122   2      
  123   2        }
  124   1      }
  125          
  126          
  127          //UART3‰∏≠Êñ≠
  128          void UART3_Isr() interrupt 17
  129          {
  130   1          if(UART3_GET_TX_FLAG)
  131   1        {
  132   2              UART3_CLEAR_TX_FLAG;
  133   2          busy[3] = 0;
  134   2        }
  135   1          if(UART3_GET_RX_FLAG)
  136   1        {
  137   2              UART3_CLEAR_RX_FLAG;
  138   2          //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS3BUF
  139   2      
  140   2        }
  141   1      }
  142          
  143          
  144          
  145          //UART4‰∏≠Êñ≠
  146          void UART4_Isr() interrupt 18
  147          {
  148   1          if(UART4_GET_TX_FLAG)
  149   1        {
  150   2              UART4_CLEAR_TX_FLAG;
  151   2          busy[4] = 0;
  152   2        }
  153   1          if(UART4_GET_RX_FLAG)
  154   1        {
  155   2              UART4_CLEAR_RX_FLAG;
  156   2          //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS4BUF;
  157   2      
  158   2          g_RxDat = S4BUF;
  159   2          g_RxData[g_RxPointer++] = g_RxDat;
  160   2        }
  161   1      }
  162          
  163          
  164          
  165          //Â§ñÈÉ®‰∏≠Êñ≠0
  166          void INT0_Isr() interrupt 0
  167          {
  168   1      
  169   1      }
  170          
  171          
  172          
  173          //Â§ñÈÉ®‰∏≠Êñ≠1
  174          void INT1_Isr() interrupt 2
  175          {
  176   1      
  177   1      }
  178          
  179          
  180          
  181          //Â§ñÈÉ®‰∏≠Êñ≠2
  182          void INT2_Isr() interrupt 10
  183          {
  184   1        INT2_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  185   1        
  186   1      }
C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 4   

  187          
  188          
  189          
  190          //Â§ñÈÉ®‰∏≠Êñ≠3
  191          void INT3_Isr() interrupt 11
  192          {
  193   1        INT3_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  194   1        
  195   1      }
  196          
  197          
  198          
  199          //Â§ñÈÉ®‰∏≠Êñ≠4
  200          void INT4_Isr() interrupt 16
  201          {
  202   1        INT4_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  203   1        
  204   1      }
  205          
  206          
  207          
  208          //ÂÆöÊó∂Âô®0‰∏≠Êñ≠
  209          void TM0_Isr() interrupt 1
  210          {
  211   1        
  212   1      }
  213          
  214          
  215          
  216          //ÂÆöÊó∂Âô®1‰∏≠Êñ≠
  217          void TM1_Isr() interrupt 3
  218          {
  219   1        int i = 0;
  220   1        
  221   1        key[0].state = P70;
  222   1        key[1].state = P71;
  223   1        key[2].state = P72;
  224   1        key[3].state = P73;
  225   1        
  226   1        for (i = 0; i < 4; i++)
  227   1        {
  228   2          switch (key[i].step)
  229   2          {
  230   3            case 0:
  231   3            {
  232   4              if (key[i].state == 0)
  233   4              {
  234   5                key[i].step = 1;
  235   5              }
  236   4            }
  237   3            break;
  238   3            
  239   3            case 1:
  240   3            {
  241   4              if (key[i].state == 0)
  242   4              {
  243   5                key[i].step = 2;
  244   5                key[i].flag = 1;
  245   5              }
  246   4              else
  247   4              {
  248   5                key[i].step = 0;
  249   5              }
  250   4            }
  251   3            break;
  252   3            
C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 5   

  253   3            case 2:
  254   3            {
  255   4              if (key[i].state == 1)
  256   4              {
  257   5                key[i].step = 0;
  258   5              }
  259   4            }
  260   3            break;
  261   3          }
  262   2        }
  263   1        
  264   1        /* ÊôÆÈÄöÂÆöÊó∂ÂäüËÉΩÔºåÂ§áÁî® */
  265   1        count++;
  266   1        if (count >= 50)
  267   1        {
  268   2          flag = 1;
  269   2          count = 0;
  270   2        }
  271   1      
  272   1          /* Ê£ÄÊµãËµõÈÅìÁ±ªÂûãÂèòÂåñÂπ∂ÊéßÂà∂ËúÇÈ∏£Âô® */
  273   1          if (track_type != track_type_last)
  274   1          {
  275   2              // ËµõÈÅìÁ±ªÂûãÂèëÁîüÂèòÂåñÔºåÂêØÂä®ËúÇÈ∏£Âô®
  276   2              beep_flag = 1;
  277   2              beep_count = 0;  // ÈáçÁΩÆËÆ°Êï∞Âô®
  278   2              P26 = 0;  // ÊâìÂºÄËúÇÈ∏£Âô®
  279   2              
  280   2              // Êõ¥Êñ∞‰∏ä‰∏ÄÊ¨°ËµõÈÅìÁ±ªÂûã
  281   2              track_type_last = track_type;
  282   2          }
  283   1          
  284   1          /* ËúÇÈ∏£Âô®ËÆ°Êó∂ÊéßÂà∂ */
  285   1          if (beep_flag)
  286   1          {
  287   2              beep_count++;
  288   2              // 10ms * 20 = 200ms
  289   2              if (beep_count >= 10)
  290   2              {
  291   3                  beep_count = 0;
  292   3                  beep_flag = 0;
  293   3                  P26 = 1;  // ÂÖ≥Èó≠ËúÇÈ∏£Âô®
  294   3              }
  295   2          } 
  296   1        
  297   1        /* Âá∫ÂÖ•ÂçÅÂ≠óÂúÜÁéØËÆ°Êó∂Âà§ÂÆö */
  298   1        if (ten_change_flag == 1)
  299   1        {
  300   2          track_ten_cnt++;
  301   2          if (track_ten_cnt >= 150)
  302   2          {
  303   3            track_ten_flag = 1;
  304   3            track_ten_cnt = 0;
  305   3            ten_change_flag = 0;
  306   3          }
  307   2        }
  308   1      }
  309          
  310          //ÂÆöÊó∂Âô®2‰∏≠Êñ≠
  311          void TM2_Isr() interrupt 12
  312          {
  313   1        TIM2_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  314   1        
  315   1        //ËØªÂèñÂπ∂Ê∏ÖÈô§ÁºñÁ†ÅÂô®ÁöÑÂÄº
  316   1        g_encoleft_init = get_left_encoder();
  317   1        g_encoright_init = get_right_encoder();
  318   1        
C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 6   

  319   1        imu963ra_get_gyro();
  320   1        Gyro_Z = imu963ra_gyro_transition(imu963ra_gyro_z);
  321   1        
  322   1      
  323   1        if (startKeyFlag == 1)
  324   1        {
  325   2          //ÂØπÁºñÁ†ÅÂô®ÁöÑÂÄºËøõË°åÊª§Ê≥¢
  326   2          g_EncoderLeft = LowPass_Filter(&leftSpeedFilt, g_encoleft_init);
  327   2          g_EncoderRight = LowPass_Filter(&rightSpeedFilt, g_encoright_init);
  328   2          
  329   2          //ÂØπÁºñÁ†ÅÂô®ÁöÑÂÄºËøõË°åÊ∂àÂà∫
  330   2          g_EncoderLeft = encoder_debounce(&EncoderDeboL, g_EncoderLeft);
  331   2          g_EncoderRight = encoder_debounce(&EncoderDeboR, g_EncoderRight);
  332   2          
  333   2          
  334   2      //    if (track_type == 0 || track_type == 1 || track_type == 2 || (track_type == 3 && track_route_status =
             -= 2))//ÊôÆÈÄöÁõ¥Á∫ø„ÄÅÁõ¥Ëßí„ÄÅÂçÅÂ≠óÂúÜÁéØÂÜÖÈÉ®ÊàñËÄÖÂúÜÁéØÂÜÖÈÉ®
  335   2      //    {
  336   2              /* 5msÁÆó‰∏ÄÊ¨°ÂÜÖÁéØÔºå15msÁÆó‰∏ÄÊ¨°Â§ñÁéØ */
  337   2              turn_count++;
  338   2              if (turn_count >= 3)
  339   2              {
  340   3                filtered_GyroZ = Kalman_Update(&imu693_kf, Gyro_Z);//ÂØπGyro_ZËøõË°åÂç°Â∞îÊõºÊª§Ê≥¢
  341   3                
  342   3                turn_pid = pid_poisitional_normal(&TurnPID, position);
  343   3        //        turn_pid = pid_poisitional_quadratic(&TurnPID, position, filtered_GyroZ);
  344   3                
  345   3                Kalman_Predict(&imu693_kf, turn_pid);//Êõ¥Êñ∞Âç°Â∞îÊõºÊª§Ê≥¢Âô®ÁöÑÂÄº
  346   3                
  347   3                turn_count = 0;
  348   3              }
  349   2              
  350   2              if(turn_pid >= 0) // Â∑¶ËΩ¨
  351   2              {
  352   3                k = turn_pid * 0.01; // Áº©ÊîæËá≥ 0.0 ~ 1.0
  353   3                g_LeftPoint = g_SpeedPoint * (1 - k);
  354   3                g_RightPoint = g_SpeedPoint * (1 + k * 0.5); // Âä†Â∞ëÂáèÂ§ö
  355   3              }
  356   2              else // Âè≥ËΩ¨
  357   2              {
  358   3                k = -turn_pid * 0.01; // ÂèñÁõ∏ÂèçÊï∞Âπ∂Áº©ÊîæËá≥ 0.0 ~ 1.0
  359   3                g_LeftPoint = g_SpeedPoint * (1 + k * 0.5); // Âä†Â∞ëÂáèÂ§ö
  360   3                g_RightPoint = g_SpeedPoint * (1 - k);
  361   3              }
  362   2            
  363   2      //    }
  364   2      //    else if (track_type == 3 && track_route_status == 1)//ÂúÜÁéØÂáÜÂ§áÂÖ•ÁéØ
  365   2      //    {
  366   2      //      if (track_route == 1)//Â∑¶ÁéØ
  367   2      //      {
  368   2      //        g_LeftPoint = g_SpeedPoint * 0.8;
  369   2      //        g_RightPoint = g_SpeedPoint * 1.2;
  370   2      //      }
  371   2      //      else if (track_route == 2)//Âè≥ÁéØ
  372   2      //      {
  373   2      //        g_LeftPoint = g_SpeedPoint * 1.2;
  374   2      //        g_RightPoint = g_SpeedPoint * 0.8;
  375   2      //      }
  376   2      //      
  377   2      //      g_intencoder += (g_EncoderLeft + g_EncoderRight) / 2;
  378   2      //      
  379   2      //      if ((g_IntEncoderL + g_IntEncoderR) / 2 > 15800)
  380   2      //      {
  381   2      //        track_route_status = 2;
  382   2      //        
  383   2      //        g_IntEncoderL = g_IntEncoderR = 0;
C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 7   

  384   2      //        
  385   2      //        P52 = 1;
  386   2      //      }
  387   2      //    }
  388   2      //    else if (track_type == 3 && track_route_status == 3)//ÂúÜÁéØÂáÜÂ§áÂá∫ÁéØ
  389   2      //    {
  390   2      //      if (track_route == 1)//Â∑¶ÁéØ
  391   2      //      {
  392   2      //        g_LeftPoint = g_SpeedPoint * 0.8;
  393   2      //        g_RightPoint = g_SpeedPoint * 1.2;
  394   2      //      }
  395   2      //      else if (track_route == 2)//Âè≥ÁéØ
  396   2      //      {
  397   2      //        g_LeftPoint = g_SpeedPoint * 1.2;
  398   2      //        g_RightPoint = g_SpeedPoint * 0.8;
  399   2      //      }
  400   2      //      
  401   2      //      if ((g_IntEncoderL + g_IntEncoderR) / 2 > 16200)
  402   2      //      {
  403   2      //        track_type = 0;
  404   2      //        track_route = 0;
  405   2      //        track_route_status = 0;
  406   2      //        
  407   2      //        g_IntEncoderL = g_IntEncoderR = 0;
  408   2      //        
  409   2      //        P52 = 1;
  410   2      //      }
  411   2      //    }
  412   2          
  413   2          //ËÆ°ÁÆóÈÄüÂ∫¶ÁéØpid
  414   2          left_pid = pid_increment_feedforward(&LeftPID, g_EncoderLeft, g_LeftPoint);
  415   2          right_pid = pid_increment_feedforward(&RightPID, g_EncoderRight, g_RightPoint);
  416   2          
  417   2          //ËΩ¨int
  418   2          g_DutyLeft = (int32_t)left_pid;
  419   2          g_DutyRight = (int32_t)right_pid;
  420   2        
  421   2          if (protection_flag == 1)
  422   2          {
  423   3            LeftPID.output = LeftPID.lasterror = LeftPID.preverror = 0;
  424   3            RightPID.output = RightPID.lasterror = RightPID.preverror = 0;
  425   3            uartSendFlag = 0;
  426   3            
  427   3            set_motor_pwm(0, 0);
  428   3          }
  429   2          else
  430   2          {
  431   3            set_motor_pwm(g_DutyLeft, g_DutyRight);
  432   3          }
  433   2        }
  434   1      }
  435          
  436          
  437          
  438          //ÂÆöÊó∂Âô®3‰∏≠Êñ≠
  439          void TM3_Isr() interrupt 19
  440          {
  441   1        TIM3_CLEAR_FLAG; //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  442   1        
  443   1      }
  444          
  445          
  446          
  447          //ÂÆöÊó∂Âô®4‰∏≠Êñ≠
  448          void TM4_Isr() interrupt 20
  449          {
C251 COMPILER V5.60.0,  isr                                                                11/05/25  15:48:19  PAGE 8   

  450   1        TIM4_CLEAR_FLAG; //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  451   1      
  452   1      
  453   1      }
  454          
  455          
  456          //void  INT0_Isr()  interrupt 0;
  457          //void  TM0_Isr()   interrupt 1;
  458          //void  INT1_Isr()  interrupt 2;
  459          //void  TM1_Isr()   interrupt 3;
  460          //void  UART1_Isr() interrupt 4;
  461          //void  ADC_Isr()   interrupt 5;
  462          //void  LVD_Isr()   interrupt 6;
  463          //void  PCA_Isr()   interrupt 7;
  464          //void  UART2_Isr() interrupt 8;
  465          //void  SPI_Isr()   interrupt 9;
  466          //void  INT2_Isr()  interrupt 10;
  467          //void  INT3_Isr()  interrupt 11;
  468          //void  TM2_Isr()   interrupt 12;
  469          //void  INT4_Isr()  interrupt 16;
  470          //void  UART3_Isr() interrupt 17;
  471          //void  UART4_Isr() interrupt 18;
  472          //void  TM3_Isr()   interrupt 19;
  473          //void  TM4_Isr()   interrupt 20;
  474          //void  CMP_Isr()   interrupt 21;
  475          //void  I2C_Isr()   interrupt 24;
  476          //void  USB_Isr()   interrupt 25;
  477          //void  PWM1_Isr()  interrupt 26;
  478          //void  PWM2_Isr()  interrupt 27;


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1292     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        54     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       132     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
