C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_function
OBJECT MODULE PLACED IN .\Out_File\zf_function.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\seekfree_libraries\zf_function.c XSMALL INTR2 FLOAT
                    -64 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree_li
                    -braries;..\seekfree_peripheral;..\libraries) DEBUG PRINT(.\Out_File\zf_function.lst) TABS(2) OBJECT(.\Out_File\zf_functi
                    -on.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library ¼´£¨AI8051U ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * AI8051U ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MDK FOR C251
   28          * ÊÊÓÃÆ½Ì¨          AI8051U
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33          * 2024-08-01        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          
   36          
   37          #include "zf_function.h"
   38          #include <stdarg.h>  // °üº¬±ê×¼¿É±ä²ÎÊýºêµÄÍ·ÎÄ¼þ
   39          #include <stdio.h>   // °üº¬±ê×¼ÊäÈëÊä³öµÄÍ·ÎÄ¼þ
   40          
   41          //-------------------------------------------------------------------------------------------------------
             -------------
   42          // º¯Êý¼ò½é     »ñÈ¡ÕûÐÍÊýµÄ×î´ó¹«Ô¼Êý ¾ÅÕÂËãÊõÖ®¸üÏà¼õËðÊõ
   43          // ²ÎÊýËµÃ÷     num1            Êý×Ö1
   44          // ²ÎÊýËµÃ÷     num2            Êý×Ö2
   45          // ·µ»Ø²ÎÊý     uint32          ×î´ó¹«Ô¼Êý
   46          // Ê¹ÓÃÊ¾Àý     return func_get_greatest_common_divisor(144, 36);               // »ñÈ¡ 144 Óë 36 µÄ×î´ó¹
             -«Ô¼Êý
   47          // ±¸×¢ÐÅÏ¢     
   48          //-------------------------------------------------------------------------------------------------------
             -------------
   49          uint32 func_get_greatest_common_divisor (uint32 num1, uint32 num2)
   50          {
   51   1          while(num1 != num2)
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 2   

   52   1          {
   53   2              if(num1 > num2)
   54   2              {
   55   3                  num1 = num1 - num2;
   56   3              }
   57   2              if(num1 < num2)
   58   2              {
   59   3                  num2 = num2 - num1;
   60   3              }
   61   2          }
   62   1          return num1;
   63   1      }
   64          
   65          //-------------------------------------------------------------------------------------------------------
             -------------
   66          // º¯Êý¼ò½é     Èí¼þÑÓÊ±
   67          // ²ÎÊýËµÃ÷     t               ÑÓÊ±Ê±¼ä
   68          // ·µ»Ø²ÎÊý     void
   69          // Ê¹ÓÃÊ¾Àý     func_soft_delay(100);
   70          // ±¸×¢ÐÅÏ¢     
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          void func_soft_delay (volatile long t)
   73          {
   74   1          while(t --);
   75   1      }
   76          
   77          //-------------------------------------------------------------------------------------------------------
             -------------
   78          // º¯Êý¼ò½é     ×Ö·û´®×ªÕûÐÎÊý×Ö Êý¾Ý·¶Î§ÊÇ [-32768,32767]
   79          // ²ÎÊýËµÃ÷     *str            ´«Èë×Ö·û´® ¿É´ø·ûºÅ
   80          // ·µ»Ø²ÎÊý     int32           ×ª»»ºóµÄÊý¾Ý          
   81          // Ê¹ÓÃÊ¾Àý     int32 dat = func_str_to_int("-100");
   82          // ±¸×¢ÐÅÏ¢     
   83          //-------------------------------------------------------------------------------------------------------
             -------------
   84          int32 func_str_to_int (char *str)
   85          {
   86   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕýÊý 1-¸ºÊý
   87   1          int32 temp = 0;                                                             // ÁÙÊ±¼ÆËã±äÁ¿
   88   1        //zf_assert(str != NULL);
   89   1        do
   90   1          {
   91   2              if(NULL == str)
   92   2              {
   93   3                  break;
   94   3              }
   95   2      
   96   2              if('-' == *str)                                                         // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇ¸ººÅ
   97   2              {
   98   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊý
   99   3                  str ++;
  100   3              }
  101   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕýºÅ
  102   2              {
  103   3                  str ++;
  104   3              }
  105   2      
  106   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊý×Ö
  107   2              {
  108   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ¼ÆËãÊýÖµ
  109   3                  str ++;
  110   3              }
  111   2      
  112   2              if(sign)
  113   2              {
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 3   

  114   3                  temp = -temp;
  115   3              }
  116   2          }while(0);
  117   1          return temp;
  118   1      }
  119          
  120          //-------------------------------------------------------------------------------------------------------
             -------------
  121          // º¯Êý¼ò½é     ÕûÐÎÊý×Ö×ª×Ö·û´® Êý¾Ý·¶Î§ÊÇ [-32768,32767]
  122          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  123          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  124          // ·µ»Ø²ÎÊý     void
  125          // Ê¹ÓÃÊ¾Àý     func_int_to_str(data_buffer, -300);
  126          // ±¸×¢ÐÅÏ¢     
  127          //-------------------------------------------------------------------------------------------------------
             -------------
  128          void func_int_to_str (char *str, int32 number)
  129          {
  130   1          uint8 data_temp[16];                                                        // »º³åÇø
  131   1          uint8 temp_bit = 0;                                                              // Êý×ÖÎ»Êý
  132   1          int32 number_temp = 0;
  133   1          //zf_assert(str != NULL);
  134   1          do
  135   1          {
  136   2              if(NULL == str)
  137   2              {
  138   3                  break;
  139   3              }
  140   2      
  141   2              if(0 > number)                                                          // ¸ºÊý
  142   2              {
  143   3                  *str ++ = '-';
  144   3                  number = -number;
  145   3              }
  146   2              else if(0 == number)                                                    // »òÕßÕâÊÇ¸ö 0
  147   2              {
  148   3                  *str = '0';
  149   3                  break;
  150   3              }
  151   2      
  152   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊýÖµ¹éÁã
  153   2              {
  154   3                  number_temp = number % 10;
  155   3                  data_temp[temp_bit ++] = func_abs(number_temp);                          // µ¹Ðò½«ÊýÖµÌáÈ¡³öÀ
             -´
  156   3                  number /= 10;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êý
  157   3              }
  158   2              while(0 != temp_bit)                                                         // ÌáÈ¡µÄÊý×Ö¸öÊýµÝ¼
             -õ´¦Àí
  159   2              {
  160   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // ½«Êý×Ö´Óµ¹ÐòÊý×éÖ
             -Ðµ¹ÐòÈ¡³ö ±ä³ÉÕýÐò·ÅÈë×Ö·û´®
  161   3                  temp_bit --;
  162   3              }
  163   2          }while(0);
  164   1      }
  165          
  166          //-------------------------------------------------------------------------------------------------------
             -------------
  167          // º¯Êý¼ò½é     ×Ö·û´®×ªÕûÐÎÊý×Ö Êý¾Ý·¶Î§ÊÇ [0,65535]
  168          // ²ÎÊýËµÃ÷     *str            ´«Èë×Ö·û´® ÎÞ·ûºÅ
  169          // ·µ»Ø²ÎÊý     uint32          ×ª»»ºóµÄÊý¾Ý          
  170          // Ê¹ÓÃÊ¾Àý     uint32 dat = func_str_to_uint("100");
  171          // ±¸×¢ÐÅÏ¢     
  172          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 4   

  173          uint32 func_str_to_uint (char *str)
  174          {
  175   1        uint32 temp = 0;                                                            // ÁÙÊ±¼ÆËã±äÁ¿
  176   1          //zf_assert(str != NULL);
  177   1      
  178   1          do
  179   1          {
  180   2              if(NULL == str)
  181   2              {
  182   3                  break;
  183   3              }
  184   2      
  185   2              while(('0' <= *str) && ('9' >= *str))                                  // È·¶¨ÕâÊÇ¸öÊý×Ö
  186   2              {
  187   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                         // ¼ÆËãÊýÖµ
  188   3                  str ++;
  189   3              }
  190   2          }while(0);
  191   1      
  192   1          return temp;
  193   1      }
  194          
  195          //-------------------------------------------------------------------------------------------------------
             -------------
  196          // º¯Êý¼ò½é     ÕûÐÎÊý×Ö×ª×Ö·û´® Êý¾Ý·¶Î§ÊÇ [0,65535]
  197          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  198          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  199          // ·µ»Ø²ÎÊý     void
  200          // Ê¹ÓÃÊ¾Àý     func_uint_to_str(data_buffer, 300);
  201          // ±¸×¢ÐÅÏ¢     
  202          //-------------------------------------------------------------------------------------------------------
             -------------
  203          void func_uint_to_str (char *str, uint32 number)
  204          {
  205   1          int8 data_temp[16];                                                         // »º³åÇø
  206   1          uint8 temp_bit = 0;                                                              // Êý×ÖÎ»Êý
  207   1          
  208   1        //zf_assert(str != NULL);
  209   1          
  210   1        do
  211   1          {
  212   2              if(NULL == str)
  213   2              {
  214   3                  break;
  215   3              }
  216   2      
  217   2              if(0 == number)                                                         // ÕâÊÇ¸ö 0
  218   2              {
  219   3                  *str = '0';
  220   3                  break;
  221   3              }
  222   2      
  223   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊýÖµ¹éÁã
  224   2              {
  225   3                  data_temp[temp_bit ++] = (number % 10);                                  // µ¹Ðò½«ÊýÖµÌáÈ¡³öÀ
             -´
  226   3                  number /= 10;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êý
  227   3              }
  228   2              while(0 != temp_bit)                                                         // ÌáÈ¡µÄÊý×Ö¸öÊýµÝ¼
             -õ´¦Àí
  229   2              {
  230   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // ½«Êý×Ö´Óµ¹ÐòÊý×éÖ
             -Ðµ¹ÐòÈ¡³ö ±ä³ÉÕýÐò·ÅÈë×Ö·û´®
  231   3                  temp_bit --;
  232   3              }
  233   2          }while(0);
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 5   

  234   1      }
  235          
  236          //-------------------------------------------------------------------------------------------------------
             -------------
  237          // º¯Êý¼ò½é     ×Ö·û´®×ª¸¡µãÊý ÓÐÐ§ÀÛ¼Æ¾«¶ÈÎªÐ¡ÊýµãºóÁùÎ»
  238          // ²ÎÊýËµÃ÷     *str            ´«Èë×Ö·û´® ¿É´ø·ûºÅ
  239          // ·µ»Ø²ÎÊý     float           ×ª»»ºóµÄÊý¾Ý          
  240          // Ê¹ÓÃÊ¾Àý     float dat = func_str_to_float("-100.2");
  241          // ±¸×¢ÐÅÏ¢     
  242          //-------------------------------------------------------------------------------------------------------
             -------------
  243          float func_str_to_float (char *str)
  244          {
  245   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕýÊý 1-¸ºÊý
  246   1          float temp = 0.0;                                                           // ÁÙÊ±¼ÆËã±äÁ¿ ÕûÊý²¿·Ö
  247   1          float temp_point = 0.0;                                                     // ÁÙÊ±¼ÆËã±äÁ¿ Ð¡Êý²¿·Ö
  248   1          float point_bit = 1;                                                        // Ð¡ÊýÀÛ¼Æ³ýÊý
  249   1          
  250   1        //zf_assert(str != NULL);
  251   1          
  252   1        do
  253   1          {
  254   2              if(NULL == str)
  255   2              {
  256   3                  break;
  257   3              }
  258   2      
  259   2              if('-' == *str)                                                         // ¸ºÊý
  260   2              {
  261   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊý
  262   3                  str ++;
  263   3              }
  264   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕýºÅ
  265   2              {
  266   3                  str ++;
  267   3              }
  268   2      
  269   2              // ÌáÈ¡ÕûÊý²¿·Ö
  270   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊý×Ö
  271   2              {
  272   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ½«ÊýÖµÌáÈ¡³öÀ´
  273   3                  str ++;
  274   3              }
  275   2              if('.' == *str)
  276   2              {
  277   3                  str ++;
  278   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000.0)      // È·ÈÏÕâÊÇ¸öÊý×Ö ²¢ÇÒ¾«¶
             -È¿ØÖÆ»¹Ã»µ½ÁùÎ»
  279   3                  {
  280   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // ÌáÈ¡Ð¡Êý²¿·ÖÊýÖµ
  281   4                      point_bit *= 10;                                                // ¼ÆËãÕâ²¿·ÖÐ¡ÊýµÄ³ýÊý
  282   4                      str ++;
  283   4                  }
  284   3                  temp_point /= point_bit;                                            // ¼ÆËãÐ¡Êý
  285   3              }
  286   2              temp += temp_point;                                                     // ½«ÊýÖµÆ´ºÏ
  287   2      
  288   2              if(sign)
  289   2              {
  290   3                  temp = -temp;
  291   3              }
  292   2          }while(0);
  293   1          return temp;
  294   1      }
  295          
  296          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 6   

             -------------
  297          // º¯Êý¼ò½é     ¸¡µãÊý×Ö×ª×Ö·û´®
  298          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  299          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  300          // ²ÎÊýËµÃ÷     point_bit       Ð¡Êýµã¾«¶È
  301          // ·µ»Ø²ÎÊý     void
  302          // Ê¹ÓÃÊ¾Àý     func_float_to_str(data_buffer, 3.1415, 2);                      // ½á¹ûÊä³ö data_buffer =
             - "3.14"
  303          // ±¸×¢ÐÅÏ¢     
  304          //-------------------------------------------------------------------------------------------------------
             -------------
  305          void func_float_to_str (char *str, float number, uint8 point_bit)
  306          {
  307   1          int data_int = 0;                                                           // ÕûÊý²¿·Ö
  308   1          int data_float = 0.0;                                                       // Ð¡Êý²¿·Ö
  309   1          int data_temp[8];                                                           // ÕûÊý×Ö·û»º³å
  310   1          int data_temp_point[6];                                                     // Ð¡Êý×Ö·û»º³å
  311   1          uint8 temp_bit = point_bit;                                                      // ×ª»»¾«¶ÈÎ»Êý
  312   1          
  313   1        //zf_assert(str != NULL);
  314   1          
  315   1        do
  316   1          {
  317   2              if(NULL == str)
  318   2              {
  319   3                  break;
  320   3              }
  321   2      
  322   2              // ÌáÈ¡ÕûÊý²¿·Ö
  323   2              data_int = (int)number;                                                 // Ö±½ÓÇ¿ÖÆ×ª»»Îª int
  324   2              if(0 > number)                                                          // ÅÐ¶ÏÔ´Êý¾ÝÊÇÕýÊý»¹ÊÇ¸º
             -Êý
  325   2              {
  326   3                  *str ++ = '-';
  327   3              }
  328   2              else if(0.0 == number)                                                  // Èç¹ûÊÇ¸ö 0
  329   2              {
  330   3                  *str ++ = '0';
  331   3                  *str ++ = '.';
  332   3                  *str = '0';
  333   3                  break;
  334   3              }
  335   2      
  336   2              // ÌáÈ¡Ð¡Êý²¿·Ö
  337   2              number = number - data_int;                                             // ¼õÈ¥ÕûÊý²¿·Ö¼´¿É
  338   2              while(temp_bit --)
  339   2              {
  340   3                  number = number * 10;                                               // ½«ÐèÒªµÄÐ¡ÊýÎ»ÊýÌáÈ¡µ½
             -ÕûÊý²¿·Ö
  341   3              }
  342   2              data_float = (int)number;                                               // »ñÈ¡Õâ²¿·ÖÊýÖµ
  343   2      
  344   2              // ÕûÊý²¿·Ö×ªÎª×Ö·û´®
  345   2              temp_bit = 0;
  346   2              do
  347   2              {
  348   3                  data_temp[temp_bit ++] = data_int % 10;                                  // ½«ÕûÊý²¿·Öµ¹ÐòÐ´È
             -ë×Ö·û»º³åÇø
  349   3                  data_int /= 10;
  350   3              }while(0 != data_int);
  351   2              while(0 != temp_bit)
  352   2              {
  353   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  354   3                  temp_bit --;
  355   3              }
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 7   

  356   2      
  357   2              // Ð¡Êý²¿·Ö×ªÎª×Ö·û´®
  358   2              if(point_bit != 0)
  359   2              {
  360   3                  temp_bit = 0;
  361   3                  *str ++ = '.';
  362   3                  if(0 == data_float)
  363   3                  {
  364   4                      *str = '0';
  365   4                  }
  366   3                  else
  367   3                  {
  368   4                      while(0 != point_bit)                                           // ÅÐ¶ÏÓÐÐ§Î»Êý
  369   4                      {
  370   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // µ¹ÐòÐ´Èë×Ö·û»º³åÇ
             -ø
  371   5                          data_float /= 10;
  372   5                          point_bit --;                                                
  373   5                      }
  374   4                      while(0 != temp_bit)
  375   4                      {
  376   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  377   5                          temp_bit --;
  378   5                      }
  379   4                  }
  380   3              }
  381   2          }while(0);
  382   1      }
  383          
  384          //-------------------------------------------------------------------------------------------------------
             -------------
  385          // º¯Êý¼ò½é     ×Ö·û´®×ª¸¡µãÊý ÓÐÐ§ÀÛ¼Æ¾«¶ÈÎªÐ¡Êýµãºó¾ÅÎ»
  386          // ²ÎÊýËµÃ÷     str             ´«Èë×Ö·û´® ¿É´ø·ûºÅ
  387          // ·µ»Ø²ÎÊý     double          ×ª»»ºóµÄÊý¾Ý          
  388          // Ê¹ÓÃÊ¾Àý     double dat = func_str_to_double("-100.2");
  389          // ±¸×¢ÐÅÏ¢     
  390          //-------------------------------------------------------------------------------------------------------
             -------------
  391          double func_str_to_double (char *str)
  392          {
  393   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕýÊý 1-¸ºÊý
  394   1          double temp = 0.0;                                                          // ÁÙÊ±¼ÆËã±äÁ¿ ÕûÊý²¿·Ö
  395   1          double temp_point = 0.0;                                                    // ÁÙÊ±¼ÆËã±äÁ¿ Ð¡Êý²¿·Ö
  396   1          double point_bit = 1;                                                       // Ð¡ÊýÀÛ¼Æ³ýÊý
  397   1          
  398   1        //zf_assert(str != NULL);
  399   1          
  400   1        do
  401   1          {
  402   2              if(NULL == str)
  403   2              {
  404   3                  break;
  405   3              }
  406   2      
  407   2              if('-' == *str)                                                         // ¸ºÊý
  408   2              {
  409   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊý
  410   3                  str ++;
  411   3              }
  412   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕýºÅ
  413   2              {
  414   3                  str ++;
  415   3              }
  416   2      
  417   2              // ÌáÈ¡ÕûÊý²¿·Ö
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 8   

  418   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊý×Ö
  419   2              {
  420   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ½«ÊýÖµÌáÈ¡³öÀ´
  421   3                  str ++;
  422   3              }
  423   2              if('.' == *str)
  424   2              {
  425   3                  str ++;
  426   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000000.0)   // È·ÈÏÕâÊÇ¸öÊý×Ö ²¢ÇÒ¾«¶
             -È¿ØÖÆ»¹Ã»µ½¾ÅÎ»
  427   3                  {
  428   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // ÌáÈ¡Ð¡Êý²¿·ÖÊýÖµ
  429   4                      point_bit *= 10;                                                // ¼ÆËãÕâ²¿·ÖÐ¡ÊýµÄ³ýÊý
  430   4                      str ++;
  431   4                  }
  432   3                  temp_point /= point_bit;                                            // ¼ÆËãÐ¡Êý
  433   3              }
  434   2              temp += temp_point;                                                     // ½«ÊýÖµÆ´ºÏ
  435   2      
  436   2              if(sign)
  437   2              {
  438   3                  temp = -temp;
  439   3              }
  440   2          }while(0);
  441   1          return temp;
  442   1      
  443   1      }
  444          
  445          //-------------------------------------------------------------------------------------------------------
             -------------
  446          // º¯Êý¼ò½é     ¸¡µãÊý×Ö×ª×Ö·û´®
  447          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  448          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  449          // ²ÎÊýËµÃ÷     point_bit       Ð¡Êýµã¾«¶È
  450          // ·µ»Ø²ÎÊý     void
  451          // Ê¹ÓÃÊ¾Àý     func_double_to_str(data_buffer, 3.1415, 2);                     // ½á¹ûÊä³ö data_buffer =
             - "3.14"
  452          // ±¸×¢ÐÅÏ¢     
  453          //-------------------------------------------------------------------------------------------------------
             -------------
  454          void func_double_to_str (char *str, double number, uint8 point_bit)
  455          {
  456   1          int data_int = 0;                                                           // ÕûÊý²¿·Ö
  457   1          int data_float = 0.0;                                                       // Ð¡Êý²¿·Ö
  458   1          int data_temp[12];                                                          // ÕûÊý×Ö·û»º³å
  459   1          int data_temp_point[9];                                                     // Ð¡Êý×Ö·û»º³å
  460   1          uint8 temp_bit = point_bit;                                                      // ×ª»»¾«¶ÈÎ»Êý
  461   1          
  462   1        //zf_assert(str != NULL);
  463   1          
  464   1        do
  465   1          {
  466   2              if(NULL == str)
  467   2              {
  468   3                  break;
  469   3              }
  470   2      
  471   2              // ÌáÈ¡ÕûÊý²¿·Ö
  472   2              data_int = (int)number;                                                 // Ö±½ÓÇ¿ÖÆ×ª»»Îª int
  473   2              if(0 > number)                                                          // ÅÐ¶ÏÔ´Êý¾ÝÊÇÕýÊý»¹ÊÇ¸º
             -Êý
  474   2              {
  475   3                  *str ++ = '-';
  476   3              }
  477   2              else if(0.0 == number)                                                  // Èç¹ûÊÇ¸ö 0
  478   2              {
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 9   

  479   3                  *str ++ = '0';
  480   3                  *str ++ = '.';
  481   3                  *str = '0';
  482   3                  break;
  483   3              }
  484   2      
  485   2              // ÌáÈ¡Ð¡Êý²¿·Ö
  486   2              number = number - data_int;                                             // ¼õÈ¥ÕûÊý²¿·Ö¼´¿É
  487   2              while(temp_bit --)
  488   2              {
  489   3                  number = number * 10;                                               // ½«ÐèÒªµÄÐ¡ÊýÎ»ÊýÌáÈ¡µ½
             -ÕûÊý²¿·Ö
  490   3              }
  491   2              data_float = (int)number;                                               // »ñÈ¡Õâ²¿·ÖÊýÖµ
  492   2      
  493   2              // ÕûÊý²¿·Ö×ªÎª×Ö·û´®
  494   2              temp_bit = 0;
  495   2              do
  496   2              {
  497   3                  data_temp[temp_bit ++] = data_int % 10;                                  // ½«ÕûÊý²¿·Öµ¹ÐòÐ´È
             -ë×Ö·û»º³åÇø
  498   3                  data_int /= 10;
  499   3              }while(0 != data_int);
  500   2              while(0 != temp_bit)
  501   2              {
  502   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  503   3                  temp_bit --;
  504   3              }
  505   2      
  506   2              // Ð¡Êý²¿·Ö×ªÎª×Ö·û´®
  507   2              if(point_bit != 0)
  508   2              {
  509   3                  temp_bit = 0;
  510   3                  *str ++ = '.';
  511   3                  if(0 == data_float)
  512   3                      *str = '0';
  513   3                  else
  514   3                  {
  515   4                      while(0 != point_bit)                                           // ÅÐ¶ÏÓÐÐ§Î»Êý
  516   4                      {
  517   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // µ¹ÐòÐ´Èë×Ö·û»º³åÇ
             -ø
  518   5                          data_float /= 10;
  519   5                          point_bit --;                                                
  520   5                      }
  521   4                      while(0 != temp_bit)
  522   4                      {
  523   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // ÔÙµ¹Ðò½«µ¹ÐòµÄÊýÖ
             -µÐ´Èë×Ö·û´® µÃµ½ÕýÐòÊýÖµ
  524   5                          temp_bit --;
  525   5                      }
  526   4                  }
  527   3              }
  528   2          }while(0);
  529   1      }
  530          
  531          //-------------------------------------------------------------------------------------------------------
             -------------
  532          // º¯Êý¼ò½é     ×Ö·û´®×ª Hex
  533          // ²ÎÊýËµÃ÷     str             ´«Èë×Ö·û´® ÎÞ·ûºÅ
  534          // ·µ»Ø²ÎÊý     uint32          ×ª»»ºóµÄÊý¾Ý
  535          // Ê¹ÓÃÊ¾Àý     uint32 dat = func_str_to_hex("0x11");
  536          // ±¸×¢ÐÅÏ¢     
  537          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 10  

  538          uint32 func_str_to_hex (char *str)
  539          {
  540   1          uint32 str_len = strlen(str);                                               // ×Ö·û´®³¤
  541   1          uint32 result_data = 0;                                                     // ½á¹û»º´æ
  542   1          uint8 temp = 0;                                                             // ¼ÆËã±äÁ¿
  543   1          uint8 flag = 0;                                                             // ±êÖ¾Î»
  544   1      
  545   1        //zf_assert(str != NULL);
  546   1        
  547   1          do
  548   1          {
  549   2              if(NULL == str)
  550   2              {
  551   3                  break;
  552   3              }
  553   2      
  554   2              if(flag)
  555   2              {
  556   3                  if(('a' <= *str) && ('f' >= *str))
  557   3                  {
  558   4                      temp = (*str - 87);
  559   4                  }
  560   3                  else if(('A' <= *str) && ('F' >= *str))
  561   3                  {
  562   4                      temp = (*str - 55);
  563   4                  }
  564   3                  else if(('0' <= *str) && ('9' >= *str))
  565   3                  {
  566   4                      temp = (*str - 48);
  567   4                  }
  568   3                  else
  569   3                  {
  570   4                      break;
  571   4                  }
  572   3                  result_data = ((result_data << 4) | (temp & 0x0F));
  573   3              }
  574   2              else
  575   2              {
  576   3      //            if(strncmp("0x", str, 2))
  577   3                  if((*str == '0') && (*(str + 1) == 'x'))
  578   3                  {
  579   4                      str ++;
  580   4                      flag = 1;
  581   4                  }
  582   3              }
  583   2              str ++;
  584   2          }while(str_len --);
  585   1      
  586   1          return result_data;
  587   1      }
  588          
  589          //-------------------------------------------------------------------------------------------------------
             -------------
  590          // º¯Êý¼ò½é     Hex ×ª×Ö·û´®
  591          // ²ÎÊýËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  592          // ²ÎÊýËµÃ÷     number          ´«ÈëµÄÊý¾Ý
  593          // ·µ»Ø²ÎÊý     void
  594          // Ê¹ÓÃÊ¾Àý     func_hex_to_str(data_buffer, 0x11);                             // ½á¹ûÊä³ö data_buffer =
             - "0x11"
  595          // ±¸×¢ÐÅÏ¢     
  596          //-------------------------------------------------------------------------------------------------------
             -------------
  597          void func_hex_to_str (char *str, uint32 number)
  598          {
  599   1          const char hex_index[16] = {
  600   1              '0', '1', '2', '3',
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 11  

  601   1              '4', '5', '6', '7',
  602   1              '8', '9', 'A', 'B',
  603   1              'C', 'D', 'E', 'F'};
  604   1          int8 data_temp[12];                                                         // »º³åÇø
  605   1          uint8 temp_bit = 0;                                                              // Êý×ÖÎ»Êý
  606   1      
  607   1          //zf_assert(str != NULL);
  608   1          
  609   1          *str++ = '0';
  610   1          *str++ = 'x';
  611   1          do
  612   1          {
  613   2              if(NULL == str)
  614   2              {
  615   3                  break;
  616   3              }
  617   2      
  618   2              if(0 == number)                                                         // ÕâÊÇ¸ö 0
  619   2              {
  620   3                  *str = '0';
  621   3                  break;
  622   3              }
  623   2      
  624   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊýÖµ¹éÁã
  625   2              {
  626   3                  data_temp[temp_bit ++] = (number & 0xF);                                 // µ¹Ðò½«ÊýÖµÌáÈ¡³öÀ
             -´
  627   3                  number >>= 4;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êý
  628   3              }
  629   2              while(0 != temp_bit)                                                         // ÌáÈ¡µÄÊý×Ö¸öÊýµÝ¼
             -õ´¦Àí
  630   2              {
  631   3                  *str ++ = hex_index[data_temp[temp_bit - 1]];                            // ½«Êý×Ö´Óµ¹ÐòÊý×éÖ
             -Ðµ¹ÐòÈ¡³ö ±ä³ÉÕýÐò·ÅÈë×Ö·û´®
  632   3                  temp_bit --;
  633   3              }
  634   2          }while(0);
  635   1      }
  636          
  637          ////-----------------------------------------------------------------------------------------------------
             ---------------
  638          //// º¯Êý¼ò½é     Êý×Ö×ª»»Îª ASCII Öµ
  639          //// ²ÎÊýËµÃ÷     dat             ´«ÈëµÄÊý¾Ý
  640          //// ²ÎÊýËµÃ÷     *p              Êý¾Ý»º³å
  641          //// ²ÎÊýËµÃ÷     neg_type        Êý¾ÝÀàÐÍ
  642          //// ²ÎÊýËµÃ÷     radix           ½øÖÆ
  643          //// ·µ»Ø²ÎÊý     uint8           Êý¾Ý
  644          //// Ê¹ÓÃÊ¾Àý     number_conversion_ascii((uint32)ival, vstr, 1, 10);
  645          //// ±¸×¢ÐÅÏ¢     ±¾º¯ÊýÔÚÎÄ¼þÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉÐÞ¸Ä
  646          ////-----------------------------------------------------------------------------------------------------
             ---------------
  647          //static uint8 number_conversion_ascii (uint32 dat, int8 *p, uint8 neg_type, uint8 radix)
  648          //{
  649          //    int32   neg_dat;
  650          //    uint32  pos_dat;
  651          //    uint8   temp_data = 0;
  652          //    uint8   valid_num = 0;
  653          
  654          //    if(neg_type)
  655          //    {
  656          //        neg_dat = (int32)dat;
  657          //        if(0 > neg_dat)
  658          //        {
  659          //            neg_dat = -neg_dat;
  660          //        }
  661          //        while(1)
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 12  

  662          //        {
  663          //            *p = neg_dat%radix + '0';
  664          //            neg_dat = neg_dat/radix;
  665          //            valid_num ++;
  666          
  667          //            if(!neg_dat)
  668          //            {
  669          //                break;
  670          //            }
  671          //            p ++;
  672          //        }
  673          //    }
  674          //    else
  675          //    {
  676          //        pos_dat = dat;
  677          //        while(1)
  678          //        {
  679          //            temp_data = pos_dat%radix;
  680          //            if(10 <= temp_data)
  681          //            {
  682          //                temp_data += 'A'-10;
  683          //            }
  684          //            else
  685          //            {
  686          //                temp_data += '0';
  687          //            }
  688          
  689          //            *p = temp_data;
  690          
  691          //            pos_dat = pos_dat/radix;
  692          //            valid_num ++;
  693          
  694          //            if(!pos_dat)
  695          //            {
  696          //                break;
  697          //            }
  698          //            p ++;
  699          //        }
  700          //    }
  701          //    return valid_num;
  702          //}
  703          
  704          ////-----------------------------------------------------------------------------------------------------
             ---------------
  705          //// º¯Êý¼ò½é     printf ÏÔÊ¾×ª»»
  706          //// ²ÎÊýËµÃ÷     *d_buff         »º³åÇø
  707          //// ²ÎÊýËµÃ÷     len             ³¤¶È
  708          //// ·µ»Ø²ÎÊý     void
  709          //// Ê¹ÓÃÊ¾Àý     printf_reverse_order(vstr, vlen);
  710          //// ±¸×¢ÐÅÏ¢     ±¾º¯ÊýÔÚÎÄ¼þÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉÐÞ¸Ä
  711          ////-----------------------------------------------------------------------------------------------------
             ---------------
  712          //static void printf_reverse_order (int8 *d_buff, uint32 len)
  713          //{
  714          //    uint32 i;
  715          //    int8  temp_data;
  716          //    for(i = 0; len / 2 > i; i ++)
  717          //    {
  718          //        temp_data = d_buff[len - 1 - i];
  719          //        d_buff[len - 1 -i ] = d_buff[i];
  720          //        d_buff[i] = temp_data; 
  721          //    }
  722          //}
  723          
  724          ////-----------------------------------------------------------------------------------------------------
             ---------------
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 13  

  725          //// º¯Êý¼ò½é     sprintf º¯ÊýÊµÏÖ
  726          //// ²ÎÊýËµÃ÷     *buff           »º³åÇø
  727          //// ²ÎÊýËµÃ÷     *format         Ô´×Ö·û´®
  728          //// ²ÎÊýËµÃ÷     ...             ¿É±ä²ÎÊýÁÐ±í
  729          //// ·µ»Ø²ÎÊý     uint32          ´¦ÀíºóÊý¾Ý³¤
  730          //// Ê¹ÓÃÊ¾Àý     zf_sprintf(buff, "Data : %d", 100);
  731          //// ±¸×¢ÐÅÏ¢     ±¾º¯ÊýÔÚÎÄ¼þÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉÐÞ¸Ä
  732          ////-----------------------------------------------------------------------------------------------------
             ---------------
  733          //uint32 zf_sprintf (int8 *buff, const int8 *format, ...)
  734          //{
  735          //    uint32 buff_len = 0;
  736          //  va_list arg;
  737          //  va_start(arg, format);
  738          
  739          //    while (*format)
  740          //    {
  741          //        int8 ret = *format;
  742          //        if ('%' == ret)
  743          //        {
  744          //            switch (*++ format)
  745          //            {
  746          //                case 'a':// Ê®Áù½øÖÆp¼ÆÊý·¨Êä³ö¸¡µãÊý ÔÝÎ´ÊµÏÖ
  747          //                    {
  748          //                    }
  749          //                    break;
  750          
  751          //                case 'c':// Ò»¸ö×Ö·û
  752          //                    {
  753          //                        int8 ch = (int8)va_arg(arg, uint32);
  754          //                        *buff = ch;
  755          //                        buff ++;
  756          //                        buff_len ++;
  757          //                    }
  758          //                    break;
  759          
  760          //                case 'd':
  761          //                case 'i':// ÓÐ·ûºÅÊ®½øÖÆÕûÊý
  762          //                    {
  763          //                        int8 vstr[33];
  764          //                        int32 ival = (int32)va_arg(arg, int32);
  765          //                        uint8 vlen = number_conversion_ascii((uint32)ival, vstr, 1, 10);
  766          
  767          //                        if(0 > ival)  
  768          //                        {
  769          //                            vstr[vlen] = '-';
  770          //                            vlen ++;
  771          //                        }
  772          //                        printf_reverse_order(vstr, vlen);
  773          //                        memcpy(buff, vstr, vlen);
  774          //                        buff += vlen;
  775          //                        buff_len += vlen;
  776          //                    }
  777          //                    break;
  778          
  779          //                case 'f':// ¸¡µãÊý£¬Êä³öÐ¡ÊýµãºóÁùÎ»  ²»ÄÜÖ¸¶¨Êä³ö¾«¶È
  780          //                case 'F':// ¸¡µãÊý£¬Êä³öÐ¡ÊýµãºóÁùÎ»  ²»ÄÜÖ¸¶¨Êä³ö¾«¶È
  781          //                {
  782          //                    int8 vstr[33];
  783          //                    double ival = (double)va_arg(arg, double);
  784          //                    uint8 vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  785          
  786          //                    if(0 > ival)  
  787          //                    {
  788          //                        vstr[vlen] = '-';
  789          //                        vlen ++;
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 14  

  790          //                    }
  791          //                    printf_reverse_order(vstr, vlen);
  792          //                    memcpy(buff, vstr, vlen);
  793          //                    buff += vlen;
  794          //                    buff_len += vlen;
  795          
  796          //                    ival = ((double)ival - (int32)ival)*1000000;
  797          //                    if(ival)
  798          //                    {
  799          //                        vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  800          //                    }
  801          //                    else
  802          //                    {
  803          //                        vstr[0] = vstr[1] = vstr[2] = vstr[3] = vstr[4] = vstr[5] = '0';
  804          //                        vlen = 6;
  805          //                    }
  806          
  807          //                    while(6 > vlen)
  808          //                    {
  809          //                        vstr[vlen] = '0';
  810          //                        vlen ++;
  811          //                    }
  812          
  813          //                    vstr[vlen] = '.';
  814          //                    vlen ++;
  815          
  816          //                    printf_reverse_order(vstr, vlen);
  817          //                    memcpy(buff, vstr, vlen);
  818          //                    buff += vlen;
  819          //                    buff_len += vlen;
  820          //                }
  821          //                break;
  822          
  823          //                case 'u':// ÎÞ·ûºÅÊ®½øÖÆÕûÊý
  824          //                    {
  825          //                        int8 vstr[33];
  826          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  827          //                        uint8 vlen = number_conversion_ascii(ival, vstr, 0, 10);
  828          
  829          //                        printf_reverse_order(vstr, vlen);
  830          //                        memcpy(buff, vstr, vlen);
  831          //                        buff += vlen;
  832          //                        buff_len += vlen;
  833          //                    }
  834          //                    break;
  835          
  836          //                case 'o':// ÎÞ·ûºÅ°Ë½øÖÆÕûÊý 
  837          //                    {
  838          //                        int8 vstr[33];
  839          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  840          //                        uint8 vlen = number_conversion_ascii(ival, vstr, 0, 8);
  841          
  842          //                        printf_reverse_order(vstr, vlen);
  843          //                        memcpy(buff, vstr, vlen);
  844          //                        buff += vlen;
  845          //                        buff_len += vlen;
  846          
  847          //                    }
  848          //                    break;
  849          
  850          //                case 'x':// ÎÞ·ûºÅÊ®Áù½øÖÆÕûÊý
  851          //                case 'X':// ÎÞ·ûºÅÊ®Áù½øÖÆÕûÊý
  852          //                    {
  853          //                        int8 vstr[33];
  854          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  855          //                        uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 15  

  856          
  857          //                        printf_reverse_order(vstr, vlen);
  858          //                        memcpy(buff, vstr, vlen);
  859          //                        buff += vlen;
  860          //                        buff_len += vlen;
  861          //                    }
  862          //                    break;
  863          
  864          //                case 's':// ×Ö·û´®
  865          //                    {
  866          //                        int8 *pc = va_arg(arg, int8 *);
  867          //                        while (*pc)
  868          //                        {
  869          //                            *buff = *pc;
  870          //                            buff ++;
  871          //                            buff_len ++;
  872          //                            pc ++;
  873          //                        }
  874          //                    }
  875          //                    break;
  876          
  877          //                case 'p':// ÒÔ16½øÖÆÐÎÊ½Êä³öÖ¸Õë
  878          //                    {
  879          //                        int8 vstr[33];
  880          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  881          //                        //uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  882          //                        number_conversion_ascii(ival, vstr, 0, 16);
  883          //                        printf_reverse_order(vstr, 8);
  884          //                        memcpy(buff, vstr, 8);
  885          //                        buff += 8;
  886          //                        buff_len += 8;
  887          //                    }
  888          //                    break;
  889          
  890          //                case '%':// Êä³ö×Ö·û% 
  891          //                    {
  892          //                        *buff = '%';
  893          //                        buff ++;
  894          //                        buff_len ++;
  895          //                    }
  896          //                    break;
  897          
  898          //                default:
  899          //                    break;
  900          //            }
  901          //        }
  902          //        else
  903          //        {
  904          //            *buff = (int8)(*format);
  905          //            buff ++;
  906          //            buff_len ++;
  907          //        }
  908          //        format ++;
  909          //    }
  910          //    va_end(arg);
  911          
  912          //    return buff_len;
  913          //}
  914          
  915          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3552     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
C251 COMPILER V5.60.0,  zf_function                                                        21/04/25  14:25:10  PAGE 16  

  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       282     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        16     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
