C251 COMPILER V5.60.0,  pid                                                                11/05/25  15:48:21  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pid
OBJECT MODULE PLACED IN .\Out_File\pid.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\pid.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SP
                    -EED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree_libraries;..\seekfree_peripheral;.
                    -.\libraries) DEBUG PRINT(.\Out_File\pid.lst) TABS(2) OBJECT(.\Out_File\pid.obj) 

stmt  level    source

    1          #include "pid.h"
    2          
    3          
    4          PID_t LeftPID;//左轮速度环PID    
    5          PID_t RightPID;//右轮速度环PID
    6          PID_t TurnPID;//转向环PID
    7          
    8          float myfabs(float num)
    9          {
   10   1        return (num > 0) ? num : -num;
   11   1      }
   12          
   13          int myabs(int num)
   14          {
   15   1        return (num > 0) ? num : -num;
   16   1      }
   17          
   18          void pid_init(PID_t* pid, float kp, float ki, float kd, float kf, float i_limit, float o_limit)
   19          {
   20   1        pid->kp = kp;
   21   1        pid->ki = ki;
   22   1        pid->kd = kd;
   23   1        pid->kf = kf;
   24   1      
   25   1        pid->i_limit = i_limit;
   26   1        pid->o_limit = o_limit; 
   27   1        
   28   1        pid->error = 0.0f;
   29   1        pid->lasterror = 0.0f;
   30   1        pid->preverror = 0.0f;
   31   1        pid->interror = 0.0f;
   32   1        pid->lasttarget = 0.0f;
   33   1        
   34   1        pid->p_out = 0.0f;
   35   1        pid->i_out = 0.0f;
   36   1        pid->d_out = 0.0f;
   37   1        pid->output = 0.0f;
   38   1      }
   39                  
   40          
   41          //位置式PID（带前馈）
   42          float pid_poisitional_feedforward(PID_t* pid, float real, float target)
   43          {
   44   1        pid->error = target - real;
   45   1        pid->interror += pid->error;
   46   1        
   47   1        //积分限幅
   48   1        if (pid->interror > pid->i_limit)
   49   1        {
   50   2          pid->interror = pid->i_limit;
   51   2        }
   52   1        else if (pid->interror < -pid->i_limit)
   53   1        {
   54   2          pid->interror = -pid->i_limit;
   55   2        }
   56   1        
   57   1        //线性、积分、微分、前馈共同作用
C251 COMPILER V5.60.0,  pid                                                                11/05/25  15:48:21  PAGE 2   

   58   1        pid->output = pid->kp * pid->error + pid->ki * pid->interror + pid->kd * (pid->error - pid->lasterror) +
             - pid->kf * (target - pid->lasttarget);
   59   1        
   60   1        pid->lasterror = pid->error;
   61   1        pid->lasttarget = target;
   62   1        
   63   1        //输出限幅
   64   1        if (pid->output > pid->o_limit)
   65   1        {
   66   2          pid->output = pid->o_limit;
   67   2        }
   68   1        else if (pid->output < -pid->o_limit)
   69   1        {
   70   2          pid->output = -pid->o_limit;
   71   2        }
   72   1        
   73   1        return pid->output; 
   74   1      }
   75          
   76          
   77          //增量式PID（带前馈）
   78          float pid_increment_feedforward(PID_t* pid, float real, float target)
   79          {
   80   1        pid->error = target - real;
   81   1        
   82   1        pid->p_out = pid->kp * (pid->error - pid->lasterror);
   83   1        pid->i_out = pid->ki * pid->error;
   84   1        pid->d_out = pid->kd * (pid->error - 2 * pid->lasterror + pid->preverror);
   85   1      
   86   1        pid->output += pid->p_out + pid->i_out + pid->d_out + pid->kf * (target - pid->lasttarget);
   87   1        
   88   1        pid->preverror = pid->lasterror;
   89   1        pid->lasterror = pid->error;
   90   1        pid->lasttarget = target;
   91   1        
   92   1        if (pid->output > pid->o_limit)
   93   1        {
   94   2          pid->output = pid->o_limit;
   95   2        }
   96   1        else if (pid->output < -pid->o_limit)
   97   1        {
   98   2          pid->output = -pid->o_limit;
   99   2        }
  100   1        
  101   1        return pid->output;
  102   1      }
  103          
  104          
  105          float pid_poisitional_normal(PID_t* pid, float position)
  106          {
  107   1        pid->error = position;
  108   1        
  109   1        pid->p_out = pid->kp * pid->error;
  110   1        pid->d_out = pid->kd * (pid->error - pid->lasterror);
  111   1      
  112   1        pid->output = pid->p_out + pid->d_out;
  113   1      
  114   1        pid->lasterror = pid->error;
  115   1        
  116   1        //输出限幅
  117   1        if (pid->output > pid->o_limit)
  118   1        {
  119   2          pid->output = pid->o_limit;
  120   2        }
  121   1        else if (pid->output < -pid->o_limit)
  122   1        {
C251 COMPILER V5.60.0,  pid                                                                11/05/25  15:48:21  PAGE 3   

  123   2          pid->output = -pid->o_limit;
  124   2        }
  125   1        
  126   1        return pid->output;
  127   1      }
  128          
  129          
  130          //魔改位置式pid（加二次项）
  131          float pid_poisitional_quadratic(PID_t* pid, float position, float GyroZ)
  132          {
  133   1        pid->p_out = (pid->kp * position) + (pid->kp * pid->kp * position * myfabs(position));
  134   1        pid->d_out = (pid->kd * (position - pid->lasterror) + (pid->kd * pid->kd * GyroZ));
  135   1        
  136   1        pid->output = pid->p_out + pid->d_out;
  137   1        pid->lasterror = position;
  138   1        
  139   1        //输出限幅
  140   1        if (pid->output > pid->o_limit)
  141   1        {
  142   2          pid->output = pid->o_limit;
  143   2        }
  144   1        else if (pid->output < -pid->o_limit)
  145   1        {
  146   2          pid->output = -pid->o_limit;
  147   2        }
  148   1        
  149   1        return pid->output;
  150   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2375     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       258     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
