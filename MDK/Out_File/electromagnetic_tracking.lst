C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE electromagnetic_tracking
OBJECT MODULE PLACED IN .\Out_File\electromagnetic_tracking.obj
COMPILER INVOKED BY: D:\keil5\C251\BIN\C251.EXE ..\USER\src\electromagnetic_tracking.c XSMALL INTR2 FLOAT64 WARNINGLEVEL
                    -(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree_libraries;..\seek
                    -free_peripheral;..\libraries) DEBUG PRINT(.\Out_File\electromagnetic_tracking.lst) OBJECT(.\Out_File\electromagnetic_tra
                    -cking.obj) 

stmt  level    source

    1          #include "electromagnetic_tracking.h"
    2          #include "headfile.h"
    3          #include "common.h"
    4          
    5          // æ»¤æ³¢åæ•°æ® - ä½¿ç”¨äºŒç»´æ•°ç»„å½¢å¼
    6          // ç¬¬ä¸€ç»´è¡¨ç¤ºç”µæ„Ÿç¼–å·ï¼š0-HL, 1-VL, 2-HML, 3-HC, 4-HMR, 5-VR, 6-HR
    7          // ç¬¬äºŒç»´ä¿ç•™ï¼Œå¯ç”¨äºå­˜å‚¨å†å²æ•°æ®
    8          #define SENSOR_COUNT 7   //ç”µæ„Ÿä¸ªæ•°
    9          #define HISTORY_COUNT 5  //æ»¤æ³¢æ¬¡æ•°
   10          
   11          uint16 adc_fliter_data[SENSOR_COUNT][HISTORY_COUNT] = {0}; //æ»¤æ³¢åçš„å€¼
   12          float result[SENSOR_COUNT] = {0};               //ç”µå­˜å‚¨æ¯ä¸ªç”µæ„Ÿæ»¤æ³¢åçš„æœ€ç»ˆç»“æœå€¼ï¼ˆå°šæœªå½’ä¸€åŒ–ï¼
             -‰ï¼Œæ˜¯è¿æ¥æ»¤æ³¢å¤„ç†å’Œå½’ä¸€åŒ–å¤„ç†çš„ä¸­é—´å˜é‡
   13          uint16 sum[SENSOR_COUNT][HISTORY_COUNT] = {0};          //ç´¯åŠ çš„å’Œ
   14          
   15          // é€’æ¨å‡å€¼æ»¤æ³¢ç›¸å…³å‚æ•°
   16          uint16 times = HISTORY_COUNT;  // æ»¤æ³¢æ¬¡æ•°
   17          uint16 i_num = SENSOR_COUNT;  // ç”µæ„Ÿæ•°é‡
   18          
   19          // å½’ä¸€åŒ–æ•°æ® - æ”¹ä¸ºæ•°ç»„å½¢å¼
   20          float normalized_data[SENSOR_COUNT] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};  // å½’ä¸€åŒ–åçš„ç”µæ
             -„Ÿæ•°æ®æ•°ç»„
   21          
   22          // å­˜å‚¨æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡† - æ”¹ä¸ºæ•°ç»„å½¢å¼
   23          uint16 min_value[SENSOR_COUNT] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};  // æ¯ä¸ªç”µæ
             -„Ÿçš„æœ€å°å€¼
   24          uint16 max_value[SENSOR_COUNT] = {0, 0, 0, 0, 0, 0, 0};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§å€¼
   25          
   26          // ç”µæ„Ÿä½ç½®è®¡ç®—ç›¸å…³å˜é‡
   27          float signal_strength_value = 0;   // ä¿¡å·å¼ºåº¦æŒ‡æ ‡
   28          int16 position = 0;
   29          
   30          // ç”µç£ä¿æŠ¤é€»è¾‘å˜é‡,0è¡¨ç¤ºæœªä¿æŠ¤ï¼Œ1è¡¨ç¤ºä¿æŠ¤
   31          uint8 protection_flag = 0;
   32          
   33          
   34          
   35          //-----------------------------------------------------------------------------
   36          // @brief       ç”µç£ä¼ æ„Ÿå™¨åˆå§‹åŒ–
   37          // @param   æ— 
   38          // @return  æ— 
   39          // @author  ZP
   40          // Sample usage: electromagnetic_init();
   41          //-----------------------------------------------------------------------------
   42          void electromagnetic_init(void)
   43          {
   44   1         uint8 i = 0, j = 0;
   45   1      
   46   1         adc_init(ADC_HL, 0);   // å·¦ä¾§æ¨ªå‘ç”µæ„Ÿ
   47   1         adc_init(ADC_VL, 0);   // å·¦ä¾§çºµå‘ç”µæ„Ÿ
   48   1         adc_init(ADC_HML, 0);  // å·¦ä¸­æ¨ªå‘ç”µæ„Ÿ
   49   1         adc_init(ADC_HC, 0);   // ä¸­é—´æ¨ªå‘ç”µæ„Ÿ
   50   1         adc_init(ADC_HMR, 0);  // å³ä¸­æ¨ªå‘ç”µæ„Ÿ
   51   1         adc_init(ADC_VR, 0);   // å³ä¾§çºµå‘ç”µæ„Ÿ
   52   1         adc_init(ADC_HR, 0);   // å³ä¾§æ¨ªå‘ç”µæ„Ÿ
   53   1         
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 2   

   54   1         // åˆå§‹åŒ–äºŒç»´æ•°ç»„
   55   1         for(i = 0; i < SENSOR_COUNT; i++)
   56   1         {
   57   2             for(j = 0; j < HISTORY_COUNT; j++)
   58   2             {
   59   3                 adc_fliter_data[i][j] = 0;
   60   3                 sum[i][j] = 0;
   61   3             }
   62   2             normalized_data[i] = 0.0f;  // åˆå§‹åŒ–å½’ä¸€åŒ–æ•°æ®æ•°ç»„
   63   2         }
   64   1      }
   65          
   66          //-----------------------------------------------------------------------------
   67          // @brief       å¾—åˆ°adcçš„å€¼
   68          // @param   æµ‹çš„ADC/ç”µæ„Ÿåºå·
   69          // @return  æµ‹å‡ºçš„adcå€¼
   70          // @author  ZP
   71          // Sample usage: get_adc(1)
   72          //-----------------------------------------------------------------------------
   73          uint16 get_adc(uint16 i)
   74          {
   75   1              switch(i){
   76   2                      case 0:
   77   2                              return adc_once(ADC_HL, ADC_10BIT);  //ADC_10BITæ˜¯ç”µç£å¯»è¿¹æœ€ä½³åˆ†è¾¨ç‡
   78   2                      case 1:
   79   2                              return adc_once(ADC_VL, ADC_10BIT);
   80   2                      case 2:
   81   2                              return adc_once(ADC_HML, ADC_10BIT);
   82   2                      case 3:
   83   2                              return adc_once(ADC_HC, ADC_10BIT);  // æ–°å¢ä¸­é—´æ¨ªå‘ç”µæ„Ÿ
   84   2                      case 4:
   85   2                              return adc_once(ADC_HMR, ADC_10BIT);
   86   2                      case 5:
   87   2                              return adc_once(ADC_VR, ADC_10BIT);
   88   2                      case 6:
   89   2                              return adc_once(ADC_HR, ADC_10BIT);
   90   2                      default:
   91   2                              return 0;
   92   2              }
   93   1      }
   94          
   95          //-----------------------------------------------------------------------------
   96          // @brief       é€’æ¨å‡å€¼æ»¤æ³¢
   97          // @param   æ— 
   98          // @return  æ— 
   99          // @author  zp
  100          // Sample usage: average_filter();
  101          //-----------------------------------------------------------------------------
  102          
  103          
  104          void average_filter(void)
  105          {
  106   1          static uint16 filter_index = 0;  // é€’æ¨æ¬¡æ•°è®¡æ•°å™¨
  107   1          static uint8 is_initialized = 0; // åˆå§‹åŒ–æ ‡å¿—,åªåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶è¿›è¡Œå¤šæ¬¡é‡‡æ ·,åç»­
             -è°ƒç”¨æ—¶ä½¿ç”¨çœŸæ­£çš„é€’æ¨ç®—æ³•   
  108   1          uint16 a = 0, b = 0;
  109   1          
  110   1          // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆå§‹åŒ–
  111   1          if (!is_initialized)
  112   1          {
  113   2              // é‡ç½®ç´¯åŠ å™¨
  114   2              for(a = 0; a < i_num; a++)
  115   2              {
  116   3                  sum[a][0] = 0;
  117   3              }
  118   2              
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 3   

  119   2              // å‰å‡ æ¬¡é‡‡é›†ï¼Œç´¯ç§¯è¶³å¤Ÿçš„æ•°æ®
  120   2              for(filter_index = 0; filter_index < times; filter_index++)
  121   2              {
  122   3                  for(b = 0; b < i_num; b++)
  123   3                  {
  124   4                      sum[b][0] += get_adc(b);  // é‡‡é›†ä¸€æ¬¡ADCå¹¶ç´¯åŠ 
  125   4                  }
  126   3                  delay_us(5); // æ·»åŠ çŸ­æš‚å»¶æ—¶æé«˜é‡‡æ ·ç¨³å®šæ€§
  127   3              }
  128   2              
  129   2              // è®¡ç®—åˆå§‹å¹³å‡å€¼
  130   2              for(a = 0; a < i_num; a++)
  131   2              {
  132   3                  adc_fliter_data[a][0] = sum[a][0] / times;  // æ±‚å¹³å‡
  133   3                  result[a] = adc_fliter_data[a][0];
  134   3              }
  135   2              
  136   2              is_initialized = 1; // æ ‡è®°åˆå§‹åŒ–å®Œæˆ
  137   2          }
  138   1          else  // å·²åˆå§‹åŒ–ï¼Œæ‰§è¡Œé€’æ¨å‡å€¼æ»¤æ³¢
  139   1          {
  140   2              for(a = 0; a < i_num; a++)
  141   2              {
  142   3                  // é€’æ¨å‡å€¼æ»¤æ³¢æ ¸å¿ƒç®—æ³•ï¼šå‡å»å¹³å‡å€¼ï¼ŒåŠ ä¸Šæ–°å€¼ï¼Œé‡æ–°è®¡ç®—å¹³å‡å€¼
  143   3                  sum[a][0] -= (sum[a][0] / times);         // æ¯æ¬¡å»é™¤å¹³å‡å€¼çš„è´¡çŒ®
  144   3                  sum[a][0] += get_adc(a);              // åŠ ä¸Šæ–°å€¼
  145   3                  adc_fliter_data[a][0] = (sum[a][0] / times);  // æ±‚æ–°çš„å¹³å‡å€¼
  146   3                  result[a] = adc_fliter_data[a][0];      // ä¿å­˜ç»“æœ
  147   3              }
  148   2          }
  149   1      }
  150          
  151          
  152          //-----------------------------------------------------------------------------
  153          // @brief       ä¸­ä½å€¼æ»¤æ³¢ï¼Œå°†æ¯ä¸ªç”µæ„Ÿçš„ä¸­ä½æ•°ä½œä¸ºç»“æœ
  154          // @param   æ— 
  155          // @return  æ— 
  156          // @author  ZP
  157          // Sample usage: mid_filter();
  158          //-----------------------------------------------------------------------------
  159          static uint8 mid_initialized = 0;  // ä¸­ä½å€¼æ»¤æ³¢åˆå§‹åŒ–æ ‡å¿—
  160          static uint16 sample_count = 0;    // é‡‡æ ·è®¡æ•°å™¨
  161          
  162          void mid_filter(void)
  163          {
  164   1          uint16 temp = 0, a = 0, t = 0;
  165   1          uint16 mid_index = 0;  //ä¸­ä½æ•°
  166   1              uint16 i = 0; //ç”¨äºå¾ªç¯
  167   1          // åˆ›å»ºä¸´æ—¶æ•°ç»„ç”¨äºæ’åºï¼Œé¿å…ä¿®æ”¹åŸå§‹æ•°æ®
  168   1          uint16 sort_array[HISTORY_COUNT];  // ä½¿ç”¨å®å®šä¹‰çš„å¸¸é‡è€Œä¸æ˜¯å˜é‡
  169   1              
  170   1          // è°ƒç”¨å‡å€¼æ»¤æ³¢è·å–æ–°çš„é‡‡æ ·å€¼
  171   1          average_filter();
  172   1          
  173   1          // å¦‚æœå°šæœªåˆå§‹åŒ–å®Œæˆ
  174   1          if (!mid_initialized)
  175   1          {
  176   2              // å°†å½“å‰æ»¤æ³¢ç»“æœå­˜å…¥å†å²æ•°ç»„
  177   2              for(a = 0; a < i_num; a++)
  178   2              {
  179   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  180   3                  result[a] = adc_fliter_data[a][0];
  181   3              }
  182   2              
  183   2              sample_count++;
  184   2              
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 4   

  185   2              // å½“é‡‡é›†åˆ°è¶³å¤Ÿæ ·æœ¬æ—¶ï¼Œæ ‡è®°åˆå§‹åŒ–å®Œæˆ
  186   2              if (sample_count >= times)
  187   2              {
  188   3                  mid_initialized = 1;
  189   3                  sample_count = 0;  // é‡ç½®è®¡æ•°å™¨ç”¨äºå¾ªç¯ç¼“å†²
  190   3              }
  191   2          }
  192   1          else  // å·²åˆå§‹åŒ–ï¼Œæ‰§è¡Œä¸­ä½å€¼æ»¤æ³¢
  193   1          {
  194   2              // æ›´æ–°å†å²æ•°æ®æ•°ç»„
  195   2              for(a = 0; a < i_num; a++)
  196   2              {
  197   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  198   3              }
  199   2              
  200   2              // æ›´æ–°å¾ªç¯ç¼“å†²åŒºç´¢å¼•
  201   2              sample_count = (sample_count + 1) % times;
  202   2              
  203   2              // å¯¹æ¯ä¸ªç”µæ„Ÿé€šé“è¿›è¡Œå¤„ç†
  204   2              for(a = 0; a < i_num; a++)
  205   2              {
  206   3                  for(t = 0; t < times; t++)
  207   3                  {
  208   4                      sort_array[t] = adc_fliter_data[a][t];
  209   4                  }
  210   3                  
  211   3                  // å†’æ³¡æ’åº
  212   3                  for(i = 0; i < times-1; i++)
  213   3                  {
  214   4                      for(t = 0; t < times-i-1; t++)
  215   4                      {
  216   5                          if(sort_array[t] > sort_array[t+1])
  217   5                          {
  218   6                              temp = sort_array[t];
  219   6                              sort_array[t] = sort_array[t+1];
  220   6                              sort_array[t+1] = temp;
  221   6                          }
  222   5                      }
  223   4                  }
  224   3                  
  225   3                  // è®¡ç®—ä¸­ä½æ•°ç´¢å¼•
  226   3                  mid_index = times / 2;  // 5 / 2 = 2  ,sort_array[2]æ˜¯ç¬¬ä¸‰ä¸ªæ•°å³ä¸­ä½æ•°
  227   3                  
  228   3                  // å–ä¸­ä½æ•°ä½œä¸ºç»“æœ
  229   3                  result[a] = sort_array[mid_index];
  230   3              }
  231   2          }
  232   1      }
  233          
  234          
  235          //-----------------------------------------------------------------------------
  236          // @brief       æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡†
  237          // @param   æ— 
  238          // @return  æ— 
  239          // @author  ZP
  240          // Sample usage: update_min_max_values();
  241          //-----------------------------------------------------------------------------
  242          void update_min_max_values(void)
  243          {
  244   1          uint8 i;
  245   1          static uint16 update_counter = 0;
  246   1          
  247   1          // å®šæœŸè½»å¾®è¡°å‡æœ€å¤§æœ€å°å€¼ï¼Œä½¿ç³»ç»Ÿèƒ½é€‚åº”ç¯å¢ƒå˜åŒ–
  248   1          update_counter++;
  249   1          if(update_counter >= 1000)  // æ¯1000æ¬¡è°ƒç”¨æ‰§è¡Œä¸€æ¬¡è¡°å‡
  250   1          {
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 5   

  251   2              update_counter = 0;
  252   2              
  253   2              // æœ€å°å€¼ç•¥å¾®å¢åŠ ï¼Œæœ€å¤§å€¼ç•¥å¾®å‡å°‘ï¼Œå½¢æˆç¼“æ…¢è¡°å‡
  254   2              for(i = 0; i < SENSOR_COUNT; i++)
  255   2              {
  256   3                  // æœ€å°å€¼å‘ä¸Šè¡°å‡ï¼ˆå¢åŠ 1%ï¼‰
  257   3                  min_value[i] += min_value[i] / 100;
  258   3                  
  259   3                  // æœ€å¤§å€¼å‘ä¸‹è¡°å‡ï¼ˆå‡å°‘1%ï¼‰
  260   3                  if(max_value[i] > min_value[i])  // ç¡®ä¿æœ€å¤§å€¼å§‹ç»ˆå¤§äºæœ€å°å€¼
  261   3                      max_value[i] -= max_value[i] / 100;
  262   3              }
  263   2          }
  264   1          
  265   1          // æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å°å€¼å’Œæœ€å¤§å€¼
  266   1          for(i = 0; i < SENSOR_COUNT; i++)
  267   1          {
  268   2              // å¼‚å¸¸å€¼æ£€æµ‹ - å¦‚æœè¯»æ•°å¼‚å¸¸å¤§æˆ–å¼‚å¸¸å°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœï¼Œä¸æ›´æ–°
  269   2              if(result[i] > 1000 || result[i] < 5)
  270   2                  continue;
  271   2                  
  272   2              // æ›´æ–°æœ€å°å€¼ï¼ˆå¿½ç•¥è¿‡å°çš„å€¼ï¼Œå¯èƒ½æ˜¯å™ªå£°ï¼‰
  273   2              if(result[i] < min_value[i] && result[i] > 10) 
  274   2                  min_value[i] = result[i];
  275   2              
  276   2              // æ›´æ–°æœ€å¤§å€¼
  277   2              if(result[i] > max_value[i]) 
  278   2                  max_value[i] = result[i];
  279   2          }
  280   1          
  281   1          // ç¡®ä¿æœ€å¤§æœ€å°å€¼ä¹‹é—´æœ‰è¶³å¤Ÿå·®è·ï¼Œé¿å…é™¤ä»¥æ¥è¿‘0çš„å€¼
  282   1          for(i = 0; i < SENSOR_COUNT; i++)
  283   1          {
  284   2              if(max_value[i] - min_value[i] < 20)
  285   2              {
  286   3                  // å¦‚æœå·®è·å¤ªå°ï¼Œå¼ºåˆ¶è®¾ç½®ä¸€ä¸ªåˆç†å·®è·
  287   3                  max_value[i] = min_value[i] + 20;
  288   3              }
  289   2          }
  290   1      }
  291          
  292          //-----------------------------------------------------------------------------
  293          // @brief       å½’ä¸€åŒ–ç”µæ„Ÿæ•°æ®
  294          // @param   æ— 
  295          // @return  æ— 
  296          // @author  ZP
  297          // Sample usage: normalize_sensors();
  298          //-----------------------------------------------------------------------------
  299          void normalize_sensors(void)
  300          {
  301   1          uint8 i;
  302   1          // å¯é€‰ï¼šå¯¹å½’ä¸€åŒ–åçš„æ•°æ®è¿›è¡Œå¹³æ»‘å¤„ç†ï¼Œå‡å°‘æŠ–åŠ¨
  303   1          static float last_normalized[SENSOR_COUNT] = {0};
  304   1          // å¹³æ»‘å› å­ï¼Œå¯è°ƒæ•´ï¼šå€¼è¶Šå¤§ï¼Œå“åº”è¶Šå¿«ä½†æŠ–åŠ¨è¶Šæ˜æ˜¾ï¼Œå€¼è¶Šå°ï¼Œå“åº”è¶Šæ…¢ä½
             -†æ›´å¹³ç¨³
  305   1          float smooth_factor = 0.7f; // å»ºè®®åœ¨0.6-0.8èŒƒå›´å†…è°ƒæ•´ï¼Œæ ¹æ®å°è½¦å®é™…è¡¨ç°å¾®è°ƒ    //
             - é¦–å…ˆæ›´æ–°æœ€å¤§æœ€å°å€¼
  306   1      
  307   1          update_min_max_values();
  308   1          
  309   1          // å¯¹æ¯ä¸ªç”µæ„Ÿè¿›è¡Œå½’ä¸€åŒ–å¤„ç†
  310   1          for(i = 0; i < SENSOR_COUNT; i++)
  311   1          {
  312   2              // æ£€æŸ¥æœ€å¤§æœ€å°å€¼å·®å¼‚æ˜¯å¦è¶³å¤Ÿå¤§ï¼Œé˜²æ­¢é™¤ä»¥æ¥è¿‘0çš„å€¼
  313   2              if(max_value[i] - min_value[i] > 20) 
  314   2              {
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 6   

  315   3                  // æ ‡å‡†çº¿æ€§å½’ä¸€åŒ–ï¼Œå°†å€¼æ˜ å°„åˆ°0-100èŒƒå›´ï¼ˆä¹˜ä»¥100æ–¹ä¾¿åç»­ä½¿ç”¨ï¼‰
  316   3                  normalized_data[i] = (float)(result[i] - min_value[i]) * 100.0f / (max_value[i] - min_value[i
             -]);
  317   3                  
  318   3                  // å¯é€‰ï¼šä½¿ç”¨å¹³æ–¹æ ¹éçº¿æ€§æ˜ å°„ï¼Œå¢å¼ºå°ä¿¡å·å“åº”(å¦‚æœå‘ç°å°è½¦å¯¹å°å
             -å·®ååº”ä¸æ•æ„Ÿï¼Œå¯ä»¥å–æ¶ˆå¹³æ–¹æ ¹æ˜ å°„çš„æ³¨é‡Š)
  319   3                  // normalized_data[i] = sqrtf(normalized_data[i] / 100.0f) * 100.0f;
  320   3              }
  321   2              else 
  322   2              {
  323   3                  // å¦‚æœæœ€å¤§æœ€å°å€¼å·®å¼‚å¤ªå°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœæˆ–æœªæ­£ç¡®åˆå§‹åŒ–
  324   3                  // ä½¿ç”¨åŸå§‹å€¼çš„ç›¸å¯¹æ¯”ä¾‹ä½œä¸ºæ›¿ä»£ï¼Œä¹Ÿä¹˜ä»¥100ä¿æŒä¸€è‡´æ€§
  325   3                  normalized_data[i] = (float)result[i] / 10.0f;  // å‡è®¾ADCæœ€å¤§å€¼ä¸º1000ï¼Œå½’ä¸€åŒ–åˆ°0-
             -100
  326   3              }
  327   2              
  328   2              // é™åˆ¶èŒƒå›´åœ¨0-100ä¹‹é—´
  329   2              if(normalized_data[i] > 100.0f) normalized_data[i] = 100.0f;
  330   2              if(normalized_data[i] < 0.0f) normalized_data[i] = 0.0f;
  331   2          }
  332   1          
  333   1          for(i = 0; i < SENSOR_COUNT; i++)
  334   1          {
  335   2              // ä½é€šæ»¤æ³¢å¹³æ»‘å¤„ç†
  336   2              normalized_data[i] = normalized_data[i] * smooth_factor + 
  337   2                                  last_normalized[i] * (1.0f - smooth_factor);
  338   2              
  339   2              // ä¿å­˜å½“å‰å€¼ç”¨äºä¸‹æ¬¡å¹³æ»‘
  340   2              last_normalized[i] = normalized_data[i];
  341   2          }
  342   1      }
  343          
  344          //-----------------------------------------------------------------------------
  345          // @brief       æ”¹è¿›ç‰ˆè®¡ç®—ä½ç½®ï¼ˆä½¿ç”¨è‡ªé€‚åº”å·®æ¯”å’ŒåŠ æƒæ–¹æ³•ï¼‰
  346          // @param   æ— 
  347          // @return  è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼ï¼ŒèŒƒå›´-100åˆ°100
  348          // @author  ZP
  349          // Sample usage: position = calculate_position_improved();
  350          //-----------------------------------------------------------------------------
  351          int16 calculate_position_improved(void)
  352          {
  353   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
  354   1          float weight_outer = 0.2f;   // å¤–ä¾§ç”µæ„Ÿæƒé‡(HLå’ŒHR)
  355   1          float weight_middle = 0.5f;  // ä¸­é—´ç”µæ„Ÿæƒé‡(HMLå’ŒHMR)
  356   1          float weight_center = 0.1f;  // ä¸­å¿ƒç”µæ„Ÿæƒé‡(HC)
  357   1          float weight_vertical = 0.2f; // çºµå‘ç”µæ„Ÿæƒé‡(VLå’ŒVR)
  358   1          
  359   1          float diff_outer = 0;        // å¤–ä¾§ç”µæ„Ÿå·®å€¼
  360   1          float diff_middle = 0;       // ä¸­é—´ç”µæ„Ÿå·®å€¼
  361   1          float diff_vertical = 0;     // çºµå‘ç”µæ„Ÿå·®å€¼
  362   1          
  363   1          float sum_outer = 0;         // å¤–ä¾§ç”µæ„Ÿå’Œå€¼
  364   1          float sum_middle = 0;        // ä¸­é—´ç”µæ„Ÿå’Œå€¼
  365   1          float sum_vertical = 0;      // çºµå‘ç”µæ„Ÿå’Œå€¼
  366   1          float center_value = 0;      // ä¸­é—´ç”µæ„Ÿå€¼
  367   1          
  368   1          float ratio_outer = 0;       // å¤–ä¾§ç”µæ„Ÿå·®æ¯”å’Œ
  369   1          float ratio_middle = 0;      // ä¸­é—´ç”µæ„Ÿå·®æ¯”å’Œ
  370   1          float ratio_vertical = 0;    // çºµå‘ç”µæ„Ÿå·®æ¯”å’Œ
  371   1          
  372   1          float signal_strength = 0;   // ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  373   1          static int16 last_pos = 0;   // ä¸Šä¸€æ¬¡ä½ç½®å€¼ï¼Œç”¨äºæ»¤æ³¢
  374   1          int16 pos = 0;               // å½“å‰è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼
  375   1          float filter_param = 0.5f;   // æ»¤æ³¢ç³»æ•°ï¼Œå¯è°ƒ
  376   1          uint8 track_type = 0;        // èµ›é“ç±»å‹ï¼š0-æ™®é€šï¼Œ1-åå­—ï¼Œ2-ç¯å²›ï¼Œ3-å¡é“
  377   1          static int16 max_change_rate = 10; // å…è®¸çš„æœ€å¤§å˜åŒ–ç‡
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 7   

  378   1          int16 position_change = 0;   // ä½ç½®å˜åŒ–é‡
  379   1              
  380   1              // ä½ç½®è®¡ç®—ï¼ˆåŒ…å«ä¸­å¿ƒç”µæ„Ÿçš„è´¡çŒ®ï¼‰
  381   1          // ä¸­å¿ƒç”µæ„Ÿè¶Šå¤§ï¼Œä½ç½®è¶Šæ¥è¿‘ä¸­å¿ƒçº¿ï¼Œè¿™é‡Œç›´æ¥å°†ä¸­å¿ƒç”µæ„Ÿä½œä¸ºä½ç½®ä¿®æ­£å› å­
             -
  382   1          float center_correction = 0;
  383   1          
  384   1          // è®¡ç®—å„å¯¹ç”µæ„Ÿçš„å·®å€¼å’Œå’Œå€¼
  385   1          diff_outer = normalized_data[SENSOR_HL] - normalized_data[SENSOR_HR];
  386   1          sum_outer = normalized_data[SENSOR_HL] + normalized_data[SENSOR_HR];
  387   1          
  388   1          diff_middle = normalized_data[SENSOR_HML] - normalized_data[SENSOR_HMR];
  389   1          sum_middle = normalized_data[SENSOR_HML] + normalized_data[SENSOR_HMR];
  390   1          
  391   1          diff_vertical = normalized_data[SENSOR_VL] - normalized_data[SENSOR_VR];
  392   1          sum_vertical = normalized_data[SENSOR_VL] + normalized_data[SENSOR_VR];
  393   1          
  394   1          // è·å–ä¸­é—´ç”µæ„Ÿå€¼
  395   1          center_value = normalized_data[SENSOR_HC];
  396   1          
  397   1          // è®¡ç®—ä¿¡å·å¼ºåº¦æŒ‡æ ‡ - æ‰€æœ‰ç”µæ„Ÿå¹³å‡å€¼
  398   1          signal_strength = (sum_outer + sum_middle + sum_vertical + center_value) / 7.0f;
  399   1          signal_strength_value = signal_strength; // ä¿å­˜ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  400   1      
  401   1          // è®¡ç®—å·®æ¯”å’Œï¼Œé¿å…é™¤ä»¥0
  402   1          if(sum_outer > 5.0f) // å¤–ä¾§ç”µæ„Ÿå€¼å¤§äº5.0f
  403   1              ratio_outer = diff_outer / sum_outer;
  404   1          else
  405   1              ratio_outer = 0;
  406   1              
  407   1          if(sum_middle > 5.0f) // æ”¹ä¸º5.0fä¸å¤–ä¾§ç”µæ„Ÿä¸€è‡´
  408   1              ratio_middle = diff_middle / sum_middle;
  409   1          else
  410   1              ratio_middle = 0;
  411   1          
  412   1          if(sum_vertical > 5.0f) // æ”¹ä¸º5.0fä¸å¤–ä¾§ç”µæ„Ÿä¸€è‡´
  413   1              ratio_vertical = diff_vertical / sum_vertical;
  414   1          else
  415   1              ratio_vertical = 0;
  416   1          
  417   1          // èµ›é“ç±»å‹è¯†åˆ« - éœ€è¦æ ¹æ®ä¸ƒç”µæ„Ÿç‰¹å¾é‡æ–°è°ƒæ•´
  418   1          // 1. åå­—è·¯å£ç‰¹å¾ï¼šä¸­é—´å’Œä¸­å¿ƒç”µæ„Ÿå€¼å¤§ï¼Œä¸¤ä¾§ç”µæ„Ÿå€¼å°
  419   1          if(normalized_data[SENSOR_HML] > 60.0f && normalized_data[SENSOR_HMR] > 60.0f && 
  420   1             normalized_data[SENSOR_HC] > 70.0f && // ä¸­å¿ƒç”µæ„Ÿå¼º
  421   1             normalized_data[SENSOR_HL] < 30.0f && normalized_data[SENSOR_HR] < 30.0f &&
  422   1             sum_vertical > 80.0f)  // å‚ç›´ç”µæ„Ÿä¹Ÿæœ‰ä¸€å®šçš„å€¼
  423   1          {
  424   2              track_type = 1; // åå­—è·¯å£
  425   2          }
  426   1          // 2. ç¯å²›ç‰¹å¾ï¼šä¸€ä¾§ç”µæ„Ÿå€¼å¾ˆå¤§ï¼Œå¦ä¸€ä¾§å¾ˆå°
  427   1          else if((normalized_data[SENSOR_HL] > 80.0f && normalized_data[SENSOR_HR] < 20.0f) ||
  428   1                  (normalized_data[SENSOR_HR] > 80.0f && normalized_data[SENSOR_HL] < 20.0f))
  429   1          {
  430   2              track_type = 2; // ç¯å²›
  431   2              
  432   2              // ç¯å²›ä¸­å¯ä»¥ä½¿ç”¨å‚ç›´ç”µæ„Ÿå’Œä¸­é—´ç”µæ„Ÿåˆ¤æ–­æ›´ç²¾ç¡®çš„ä½ç½®
  433   2              if(normalized_data[SENSOR_VL] > 70.0f && normalized_data[SENSOR_VR] < 30.0f)
  434   2              {
  435   3                  // å·¦ç¯å²›
  436   3              }
  437   2              else if(normalized_data[SENSOR_VL] < 30.0f && normalized_data[SENSOR_VR] > 70.0f)
  438   2              {
  439   3                  // å³ç¯å²›
  440   3              }
  441   2          }
  442   1          // 3. å¡é“ç‰¹å¾ï¼šæ‰€æœ‰ç”µæ„Ÿå€¼éƒ½è¾ƒå¤§
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 8   

  443   1          else if(normalized_data[SENSOR_HL] > 70.0f && normalized_data[SENSOR_HR] > 70.0f &&
  444   1                  normalized_data[SENSOR_HML] > 70.0f && normalized_data[SENSOR_HMR] > 70.0f)
  445   1          {
  446   2              track_type = 3; // å¡é“
  447   2          }
  448   1          
  449   1          // æ ¹æ®èµ›é“ç±»å‹å’Œä¿¡å·å¼ºåº¦è°ƒæ•´æƒé‡
  450   1          switch(track_type)
  451   1          {
  452   2              case 0: // æ™®é€šèµ›é“
  453   2                  // æ ¹æ®ä¿¡å·å¼ºåº¦åŠ¨æ€è°ƒæ•´æƒé‡
  454   2                  if(signal_strength > 70.0f) // ä¿¡å·å¼ºï¼Œå¯èƒ½åœ¨ç›´é“
  455   2                  {
  456   3                      weight_outer = 0.25f;  // é€‚å½“å¹³è¡¡ä¸­é—´å’Œå¤–ä¾§ç”µæ„Ÿçš„æƒé‡
  457   3                      weight_middle = 0.45f;
  458   3                      weight_center = 0.1f;  // ä¸­å¿ƒç”µæ„Ÿç»™è¾ƒå°æƒé‡
  459   3                      weight_vertical = 0.2f;
  460   3                      filter_param = 0.6f;  // ç›´é“ä¸Šå¯ä»¥ç¨å¾®çµæ•ä¸€äº›
  461   3                      max_change_rate = 15;  // ç›´é“å…è®¸æ›´å¤§å˜åŒ–ç‡
  462   3                  }
  463   2                  else if(signal_strength < 30.0f) // ä¿¡å·å¼±ï¼Œå¯èƒ½åœ¨å¼¯é“
  464   2                  {
  465   3                      weight_outer = 0.4f;
  466   3                      weight_middle = 0.3f;
  467   3                      weight_center = 0.1f;
  468   3                      weight_vertical = 0.2f;
  469   3                      filter_param = 0.4f;  // å¼¯é“å¤„æé«˜æ»¤æ³¢åŠ›åº¦ï¼Œå¹³æ»‘å˜åŒ–
  470   3                      max_change_rate = 8;   // å¼¯é“å‡å°å˜åŒ–ç‡
  471   3                  }
  472   2                  else
  473   2                  {
  474   3                      // é»˜è®¤æƒé‡
  475   3                      weight_outer = 0.3f;
  476   3                      weight_middle = 0.4f;
  477   3                      weight_center = 0.1f;
  478   3                      weight_vertical = 0.2f;
  479   3                      filter_param = 0.5f;
  480   3                      max_change_rate = 10;
  481   3                  }
  482   2                  break;
  483   2                  
  484   2              case 1: // åå­—è·¯å£
  485   2                  // åå­—è·¯å£ä¸­å¿ƒç”µæ„Ÿæ›´é‡è¦
  486   2                  weight_outer = 0.2f;
  487   2                  weight_middle = 0.4f;
  488   2                  weight_center = 0.2f;  // åå­—è·¯å£ä¸­å¿ƒç”µæ„Ÿç»™è¾ƒå¤§æƒé‡
  489   2                  weight_vertical = 0.2f;
  490   2                  filter_param = 0.5f;
  491   2                  max_change_rate = 10;
  492   2                  break;
  493   2                  
  494   2              case 2: // ç¯å²›
  495   2                  // ç¯å²›æ›´ä¾èµ–å¤–ä¾§ç”µæ„Ÿ
  496   2                  weight_outer = 0.5f;
  497   2                  weight_middle = 0.3f;
  498   2                  weight_center = 0.1f;
  499   2                  weight_vertical = 0.1f;
  500   2                  filter_param = 0.7f;
  501   2                  max_change_rate = 12;
  502   2                  break;
  503   2                  
  504   2              case 3: // å¡é“
  505   2                  // å¡é“ä½¿ç”¨å¹³å‡æƒé‡
  506   2                  weight_outer = 0.25f;
  507   2                  weight_middle = 0.3f;
  508   2                  weight_center = 0.15f;
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 9   

  509   2                  weight_vertical = 0.3f;
  510   2                  filter_param = 0.6f;
  511   2                  max_change_rate = 10;
  512   2                  break;
  513   2      
  514   2              default:
  515   2                  break;
  516   2          }
  517   1          
  518   1          // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå½“æ‰€æœ‰ç”µæ„Ÿå€¼éƒ½å¾ˆå°æ—¶ï¼Œå¯èƒ½å·²ç»åç¦»èµ›é“
  519   1          if(sum_outer < 10.0f && sum_middle < 10.0f && sum_vertical < 10.0f && center_value < 10.0f)
  520   1          {
  521   2              // æ ¹æ®ä¸Šä¸€æ¬¡ä½ç½®åˆ¤æ–­åç¦»æ–¹å‘
  522   2              if(last_pos > 0)
  523   2                  return 100;  // å‘å³åç¦»
  524   2              else
  525   2                  return -100; // å‘å·¦åç¦»
  526   2          }
  527   1          
  528   1          
  529   1          
  530   1          // å½“ä¸­å¿ƒç”µæ„Ÿå¤§äºé˜ˆå€¼æ—¶ï¼Œè®¤ä¸ºè½¦è¾†æ¥è¿‘ä¸­å¿ƒï¼Œå¯¹ä½ç½®è¿›è¡Œä¿®æ­£
  531   1          if(center_value > 50.0f) {
  532   2              // ä¿®æ­£ç³»æ•°ï¼Œå½“ä¸­å¿ƒç”µæ„Ÿå¼ºåº¦é«˜æ—¶ï¼Œä¿®æ­£ç³»æ•°å¤§
  533   2              center_correction = (center_value - 50.0f) / 50.0f * 0.3f;  // æœ€å¤§ä¿®æ­£30%
  534   2          }
  535   1          
  536   1          // ä¸‰ç»„å·®æ¯”å’ŒåŠ æƒå¹³å‡è®¡ç®—ä½ç½®
  537   1          pos = (int16)((ratio_outer * weight_outer + 
  538   1                         ratio_middle * weight_middle + 
  539   1                         ratio_vertical * weight_vertical) * 100.0f);
  540   1          
  541   1          // åº”ç”¨ä¸­å¿ƒç”µæ„Ÿä¿®æ­£ - å‘ä¸­å¿ƒçº¿æ‹‰è¿‘
  542   1          pos = (int16)(pos * (1.0f - center_correction));
  543   1          
  544   1          // é™åˆ¶èŒƒå›´åœ¨-100åˆ°100ä¹‹é—´
  545   1          if(pos > 100) pos = 100;
  546   1          if(pos < -100) pos = -100;
  547   1          
  548   1          // ä½ç½®å˜åŒ–é‡é™åˆ¶ï¼Œé˜²æ­¢çªå˜
  549   1          position_change = pos - last_pos;
  550   1          if(position_change > max_change_rate)
  551   1              pos = last_pos + max_change_rate;
  552   1          else if(position_change < -max_change_rate)
  553   1              pos = last_pos - max_change_rate;
  554   1          
  555   1          // åº”ç”¨ä½é€šæ»¤æ³¢
  556   1          pos = (int16)(filter_param * pos + (1-filter_param) * last_pos);
  557   1          
  558   1          // ä¿å­˜å½“å‰ä½ç½®ç”¨äºä¸‹æ¬¡è®¡ç®—
  559   1          last_pos = pos;
  560   1          
  561   1          return pos;
  562   1      }
  563          
  564          
  565          //-----------------------------------------------------------------------------
  566          // @brief       ç”µç£ä¿æŠ¤é€»è¾‘å‡½æ•°
  567          // @param   æ— 
  568          // @return  ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  569          // @author  ZP
  570          // Sample usage: protection_flag = check_electromagnetic_protection();
  571          //-----------------------------------------------------------------------------
  572          uint8 check_electromagnetic_protection(void)
  573          {
  574   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 10  

  575   1          uint8 is_out_of_track = 0;    // æ ‡è®°æ˜¯å¦è„±ç¦»èµ›é“çš„æ ‡å¿—ä½
  576   1          uint16 sum_value = 0;         // æ‰€æœ‰ç”µæ„Ÿå€¼çš„æ€»å’Œ
  577   1          uint16 threshold = 175;       // é˜ˆå€¼ï¼Œéœ€è¦æ ¹æ®ä¸ƒç”µæ„Ÿçš„å®é™…æƒ…å†µè°ƒæ•´ï¼ˆå¢åŠ ï¼‰
  578   1          static uint8 out_of_track_count = 0;    // è¿ç»­æ£€æµ‹åˆ°è„±ç¦»èµ›é“çš„æ¬¡æ•°è®¡æ•°å™¨
  579   1          static uint8 in_track_count = 0;        // è¿ç»­æ£€æµ‹åˆ°åœ¨è½¨é“ä¸Šçš„æ¬¡æ•°è®¡æ•°å™¨
  580   1          static uint8 protection_triggered = 0;  // ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  581   1          uint8 i;
  582   1          uint8 trigger_reason = 0;     // è®°å½•è§¦å‘åŸå› ï¼Œç”¨äºè°ƒè¯•
  583   1          
  584   1          // è®¡ç®—æ‰€æœ‰ç”µæ„Ÿçš„å’Œå€¼
  585   1          for(i = 0; i < SENSOR_COUNT; i++)
  586   1          {
  587   2              sum_value += result[i];
  588   2          }
  589   1          
  590   1          // åˆ¤æ–­æ˜¯å¦è„±ç¦»èµ›é“çš„æ¡ä»¶
  591   1          // 1. æ‰€æœ‰ç”µæ„Ÿå€¼æ€»å’Œè¿‡å°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
  592   1          if(sum_value < threshold)
  593   1          {
  594   2              is_out_of_track = 1;
  595   2              trigger_reason = 1;
  596   2          }
  597   1          
  598   1          // 2. å½’ä¸€åŒ–åçš„å€¼éƒ½å¾ˆå°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
  599   1          if(normalized_data[SENSOR_HL] < 5.0f && normalized_data[SENSOR_VL] < 5.0f && 
  600   1             normalized_data[SENSOR_HML] < 5.0f && normalized_data[SENSOR_HC] < 5.0f && 
  601   1             normalized_data[SENSOR_HMR] < 5.0f && normalized_data[SENSOR_VR] < 5.0f && 
  602   1             normalized_data[SENSOR_HR] < 5.0f)
  603   1          {
  604   2              is_out_of_track = 1;
  605   2              trigger_reason = 2;
  606   2          }
  607   1          
  608   1          // 3. ä½ç½®åå·®è¿‡å¤§ï¼Œè¯´æ˜å¯èƒ½åç¦»èµ›é“å¤ªå¤š
  609   1          if(position < -90 || position > 90)
  610   1          {
  611   2              // åªæœ‰å½“ç”µæ„Ÿå€¼æ€»å’Œä¹Ÿè¾ƒå°æ—¶æ‰åˆ¤æ–­ä¸ºå‡ºèµ›é“
  612   2              if(sum_value < threshold * 2)
  613   2              {
  614   3                  is_out_of_track = 1;
  615   3                  trigger_reason = 3;
  616   3              }
  617   2          }
  618   1          
  619   1          // è¿ç»­æ£€æµ‹é€»è¾‘ï¼Œé˜²æ­¢å¶ç„¶çš„ä½å€¼å¯¼è‡´è¯¯åˆ¤
  620   1          if(is_out_of_track)
  621   1          {
  622   2              out_of_track_count++;
  623   2              in_track_count = 0;  // é‡ç½®åœ¨è½¨é“ä¸Šçš„è®¡æ•°
  624   2              
  625   2              if(out_of_track_count >= 5 && !protection_triggered)  // è¿ç»­5æ¬¡æ£€æµ‹åˆ°è„±ç¦»èµ›é“æ‰è§¦å‘
             -ä¿æŠ¤
  626   2              {
  627   3                  protection_triggered = 1;
  628   3                  // è¿™é‡Œå¯ä»¥è¾“å‡ºè§¦å‘ä¿æŠ¤çš„ä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•
  629   3                  // sprintf(g_TxData, "Protection triggered! Reason: %d, Sum: %d\n", trigger_reason, sum_value
             -);
  630   3                  // uart_putstr(UART_4, g_TxData);
  631   3              }
  632   2          }
  633   1          else
  634   1          {
  635   2              // å¦‚æœæ£€æµ‹æ­£å¸¸ï¼Œè®¡æ•°å™¨å¢åŠ 
  636   2              in_track_count++;
  637   2              if(out_of_track_count > 0)
  638   2                  out_of_track_count--;
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 11  

  639   2                  
  640   2              // è‡ªåŠ¨æ¢å¤æœºåˆ¶ï¼šè¿ç»­20æ¬¡æ£€æµ‹åˆ°æ­£å¸¸ï¼Œåˆ™è§£é™¤ä¿æŠ¤çŠ¶æ€
  641   2              if(in_track_count >= 20 && protection_triggered)
  642   2              {
  643   3                  protection_triggered = 0;
  644   3                  out_of_track_count = 0;
  645   3                  in_track_count = 0;
  646   3                  // å¯ä»¥è¾“å‡ºè‡ªåŠ¨æ¢å¤çš„ä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•
  647   3                  // sprintf(g_TxData, "Protection auto reset!\n");
  648   3                  // uart_putstr(UART_4, g_TxData);
  649   3              }
  650   2          }
  651   1          
  652   1          return protection_triggered;
  653   1      }
  654          
  655          // æ˜¾ç¤ºç”µç£ä¼ æ„Ÿå™¨æ•°æ®
  656          void display_electromagnetic_data(void)
  657          {
  658   1          // æ˜¾ç¤ºåŸå§‹æ»¤æ³¢æ•°æ®å’Œå½’ä¸€åŒ–æ•°æ®
  659   1          ips114_showstr_simspi(0,0,"HL:");   
  660   1          ips114_showuint16_simspi(3*8, 0, result[SENSOR_HL]);
  661   1          ips114_showstr_simspi(9*8,0,"N:");
  662   1          ips114_showfloat_simspi(11*8, 0, normalized_data[SENSOR_HL], 2, 2);
  663   1          
  664   1          ips114_showstr_simspi(0,1,"VL:");  
  665   1          ips114_showuint16_simspi(3*8, 1, result[SENSOR_VL]);
  666   1          ips114_showstr_simspi(9*8,1,"N:");
  667   1          ips114_showfloat_simspi(11*8, 1, normalized_data[SENSOR_VL], 2, 2);
  668   1          
  669   1          ips114_showstr_simspi(0,2,"HML:");  
  670   1          ips114_showuint16_simspi(4*8, 2, result[SENSOR_HML]);
  671   1          ips114_showstr_simspi(9*8,2,"N:");
  672   1          ips114_showfloat_simspi(11*8, 2, normalized_data[SENSOR_HML], 2, 2);
  673   1          
  674   1          ips114_showstr_simspi(0,3,"HC:");   
  675   1          ips114_showuint16_simspi(3*8, 3, result[SENSOR_HC]);
  676   1          ips114_showstr_simspi(9*8,3,"N:");
  677   1          ips114_showfloat_simspi(11*8, 3, normalized_data[SENSOR_HC], 2, 2);
  678   1          
  679   1          ips114_showstr_simspi(0,4,"HMR:");   
  680   1          ips114_showuint16_simspi(4*8, 4, result[SENSOR_HMR]);
  681   1          ips114_showstr_simspi(9*8,4,"N:");
  682   1          ips114_showfloat_simspi(11*8, 4, normalized_data[SENSOR_HMR], 2, 2);
  683   1          
  684   1          ips114_showstr_simspi(0,5,"VR:");   
  685   1          ips114_showuint16_simspi(3*8, 5, result[SENSOR_VR]);
  686   1          ips114_showstr_simspi(9*8,5,"N:");
  687   1          ips114_showfloat_simspi(11*8, 5, normalized_data[SENSOR_VR], 2, 2);
  688   1          
  689   1          ips114_showstr_simspi(0,6,"HR:");   
  690   1          ips114_showuint16_simspi(3*8, 6, result[SENSOR_HR]);
  691   1          ips114_showstr_simspi(9*8,6,"N:");
  692   1          ips114_showfloat_simspi(11*8, 6, normalized_data[SENSOR_HR], 2, 2);
  693   1          
  694   1          // æ˜¾ç¤ºä½ç½®å’Œå·®æ¯”å’Œæ•°æ®
  695   1          ips114_showstr_simspi(0,7,"Pos:");
  696   1          ips114_showint16_simspi(5*8, 7, position);
  697   1          
  698   1          // æ˜¾ç¤ºä¿æŠ¤çŠ¶æ€
  699   1          ips114_showstr_simspi(10*8,7,"P:");
  700   1          ips114_showuint8_simspi(12*8, 7, protection_flag);
  701   1      } 


Module Information          Static   Overlayable
------------------------------------------------
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           17/04/25  14:34:19  PAGE 12  

  code size            =      5516     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       392     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       407     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
