C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE electromagnetic_tracking
OBJECT MODULE PLACED IN .\Out_File\electromagnetic_tracking.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\electromagnetic_tracking.c XSMALL WARNINGL
                    -EVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree_libraries;..\
                    -seekfree_peripheral;..\libraries) DEBUG PRINT(.\Out_File\electromagnetic_tracking.lst) TABS(2) OBJECT(.\Out_File\electro
                    -magnetic_tracking.obj) 

stmt  level    source

    1          #include "electromagnetic_tracking.h"
    2          #include "headfile.h"
    3          #include "common.h"
    4          
    5          // æ»¤æ³¢åæ•°æ® - ä½¿ç”¨äºŒç»´æ•°ç»„å½¢å¼
    6          // ç¬¬ä¸€ç»´è¡¨ç¤ºç”µæ„Ÿç¼–å·ï¼š0-HL, 1-VL, 2-HML, 3-HC, 4-HMR, 5-VR, 6-HR
    7          // ç¬¬äºŒç»´ä¿ç•™ï¼Œå¯ç”¨äºå­˜å‚¨å†å²æ•°æ®
    8          #define SENSOR_COUNT 7   //ç”µæ„Ÿä¸ªæ•°
    9          #define HISTORY_COUNT 5  //æ»¤æ³¢æ¬¡æ•°
   10          
   11          // èµ›é“ç±»å‹ç´¢å¼•ï¼Œä¸track_typeå¯¹åº”
   12          #define WEIGHT_STRAIGHT    0  // ç›´é“
   13          #define WEIGHT_RIGHT_ANGLE 1  // ç›´è§’å¼¯é“
   14          #define WEIGHT_CROSS       2  // åå­—åœ†ç¯
   15          #define WEIGHT_ROUNDABOUT  3  // ç¯å²›
   16          
   17          // å®šä¹‰ç”µæ„Ÿæƒé‡ç»“æ„ä½“
   18          
   19          // å®šä¹‰å…¨å±€æƒé‡é…ç½®ï¼Œåªä¿ç•™å››ç§åŸºæœ¬å…ƒç´ 
   20          TrackWeights track_weights[] = {
   21              // æ™®é€šç›´é“
   22          
   23              {0.15f, 0.40f, 0.30f, 0.15f, 0.3f, 5, "ç›´é“"},
   24              
   25              // ç›´è§’å¼¯é“
   26              {0.15f, 0.40f, 0.30f, 0.25f, 0.8f, 30, "ç›´è§’å¼¯é“"},
   27              
   28              // åå­—åœ†ç¯
   29              {0.06f, 0.4f, 0.2f, 0.06f, 0.4f, 10, "åå­—åœ†ç¯"},
   30              
   31              // ç¯å²›
   32              {0.15f, 0.4f, 0.1f, 0.15f, 0.7f, 12, "ç¯å²›"}
   33          };
   34          
   35          uint16 adc_fliter_data[SENSOR_COUNT][HISTORY_COUNT] = {0}; //æ»¤æ³¢åçš„å€¼
   36          float result[SENSOR_COUNT] = {0};   //ç”µå­˜å‚¨æ¯ä¸ªç”µæ„Ÿæ»¤æ³¢åçš„æœ€ç»ˆç»“æœå€¼ï¼ˆå°šæœªå½’ä¸€åŒ–ï¼
             -‰ï¼Œæ˜¯è¿æ¥æ»¤æ³¢å¤„ç†å’Œå½’ä¸€åŒ–å¤„ç†çš„ä¸­é—´å˜é‡
   37          uint16 sum[SENSOR_COUNT][HISTORY_COUNT] = {0};        //ç´¯åŠ çš„å’Œ
   38          
   39          // é€’æ¨å‡å€¼æ»¤æ³¢ç›¸å…³å‚æ•°
   40          uint16 times = HISTORY_COUNT;  // æ»¤æ³¢æ¬¡æ•°
   41          uint16 i_num = SENSOR_COUNT;  // ç”µæ„Ÿæ•°é‡
   42          
   43          // å½’ä¸€åŒ–æ•°æ® - æ”¹ä¸ºæ•°ç»„å½¢å¼
   44          float normalized_data[SENSOR_COUNT] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};  // å½’ä¸€åŒ–åçš„ç”µæ
             -„Ÿæ•°æ®æ•°ç»„
   45          
   46          // å­˜å‚¨æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡† - æ”¹ä¸ºæ•°ç»„å½¢å¼
   47          // uint16 min_value[SENSOR_COUNT] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};  // æ¯ä¸ªç
             -”µæ„Ÿçš„æœ€å°å€¼
   48          // uint16 max_value[SENSOR_COUNT] = {0, 0, 0, 0, 0, 0, 0};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§å€¼
   49          uint16 min_value[SENSOR_COUNT] = {0, 0, 0, 0, 0, 0, 0};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å°å€¼
   50          uint16 max_value[SENSOR_COUNT] = {1000, 980, 1000, 880, 1023, 1023, 1023};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§å€¼
   51          
   52          // ç”µæ„Ÿä½ç½®è®¡ç®—ç›¸å…³å˜é‡
   53          float signal_strength_value = 0;   // ä¿¡å·å¼ºåº¦æŒ‡æ ‡
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 2   

   54          int16 position = 0;
   55          float filter_param = 0.4f;   // æ»¤æ³¢ç³»æ•°ï¼Œå¯è°ƒ è¶Šå¤§è¶Šçµæ•
   56          
   57          
   58          // èµ›é“ä¿¡æ¯ç›¸å…³æ ‡å¿—ä½
   59          uint8 track_type = 0;         // èµ›é“ç±»å‹ï¼š0-æ™®é€šï¼Œ1-ç›´è§’å¼¯é“ï¼Œ2-åå­—åœ†ç¯ï¼Œ3-ç¯å²›
   60          uint8 track_type_last = 0;         // èµ›é“ç±»å‹ï¼š0-æ™®é€šï¼Œ1-ç›´è§’å¼¯é“ï¼Œ2-åå­—åœ†ç¯ï¼Œ3-ç¯å²
             -›
   61          
   62          uint8 track_type_zj = 0;    //1-å·¦ç›´è§’ï¼Œ2-å³ç›´è§’
   63          uint8 track_route = 0;      //1-å³ç¯ï¼Œ2-å·¦ç¯
   64          uint8 track_route_status = 0; //1-å…¥ç¯ï¼Œ2-ç¯ä¸­ï¼Œ3-å‡ºç¯
   65          uint8 track_ten_flag = 1; //åå­—åœ†ç¯ï¼š0è¡¨ç¤ºåˆ°è®¡æ—¶0.5så†å¼€å§‹åˆ¤æ–­ï¼Œ1-å¯ä»¥å¼€å§‹åˆ¤æ–­
   66          uint8 ten_change_flag = 0; //1è¡¨ç¤º0.5åtrack_ten_flag=1
   67          
   68          uint8 protection_flag = 0;// ç”µç£ä¿æŠ¤é€»è¾‘å˜é‡,0è¡¨ç¤ºæœªä¿æŠ¤ï¼Œ1è¡¨ç¤ºä¿æŠ¤
   69          
   70          
   71          //-----------------------------------------------------------------------------
   72          // @brief   ç”µç£ä¼ æ„Ÿå™¨åˆå§‹åŒ–
   73          // @param   æ— 
   74          // @return  æ— 
   75          // @author  ZP
   76          // Sample usage: electromagnetic_init();
   77          //-----------------------------------------------------------------------------
   78          void electromagnetic_init(void)
   79          {
   80   1         uint8 i = 0, j = 0;
   81   1      
   82   1         adc_init(ADC_HL, 0);   // å·¦ä¾§æ¨ªå‘ç”µæ„Ÿ
   83   1         adc_init(ADC_VL, 0);   // å·¦ä¾§çºµå‘ç”µæ„Ÿ
   84   1         adc_init(ADC_HML, 0);  // å·¦ä¸­æ¨ªå‘ç”µæ„Ÿ
   85   1         adc_init(ADC_HC, 0);   // ä¸­é—´æ¨ªå‘ç”µæ„Ÿ
   86   1         adc_init(ADC_HMR, 0);  // å³ä¸­æ¨ªå‘ç”µæ„Ÿ
   87   1         adc_init(ADC_VR, 0);   // å³ä¾§çºµå‘ç”µæ„Ÿ
   88   1         adc_init(ADC_HR, 0);   // å³ä¾§æ¨ªå‘ç”µæ„Ÿ
   89   1         
   90   1         // åˆå§‹åŒ–äºŒç»´æ•°ç»„
   91   1         for(i = 0; i < SENSOR_COUNT; i++)
   92   1         {
   93   2             for(j = 0; j < HISTORY_COUNT; j++)
   94   2             {
   95   3                 adc_fliter_data[i][j] = 0;
   96   3                 sum[i][j] = 0;
   97   3             }
   98   2             normalized_data[i] = 0.0f;  // åˆå§‹åŒ–å½’ä¸€åŒ–æ•°æ®æ•°ç»„
   99   2         }
  100   1      }
  101          
  102          //-----------------------------------------------------------------------------
  103          // @brief   å¾—åˆ°adcçš„å€¼
  104          // @param   æµ‹çš„ADC/ç”µæ„Ÿåºå·
  105          // @return  æµ‹å‡ºçš„adcå€¼
  106          // @author  ZP
  107          // Sample usage: get_adc(1)
  108          //-----------------------------------------------------------------------------
  109          uint16 get_adc(uint16 i)
  110          {
  111   1        switch(i){
  112   2          case 0:
  113   2            return adc_once(ADC_HL, ADC_10BIT);  //ADC_10BITæ˜¯ç”µç£å¯»è¿¹æœ€ä½³åˆ†è¾¨ç‡
  114   2          case 1:
  115   2            return adc_once(ADC_VL, ADC_10BIT);
  116   2          case 2:
  117   2            return adc_once(ADC_HML, ADC_10BIT);
  118   2          case 3:
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 3   

  119   2            return adc_once(ADC_HC, ADC_10BIT); 
  120   2          case 4:
  121   2            return adc_once(ADC_HMR, ADC_10BIT);
  122   2          case 5:
  123   2            return adc_once(ADC_VR, ADC_10BIT);
  124   2          case 6:
  125   2            return adc_once(ADC_HR, ADC_10BIT);
  126   2          default:
  127   2            return 0;
  128   2        }
  129   1      }
  130          
  131          //-----------------------------------------------------------------------------
  132          // @brief   é€’æ¨å‡å€¼æ»¤æ³¢
  133          // @param   æ— 
  134          // @return  æ— 
  135          // @author  zp
  136          // Sample usage: average_filter();
  137          //-----------------------------------------------------------------------------
  138          
  139          
  140          void average_filter(void)
  141          {
  142   1          static uint16 filter_index = 0;  // é€’æ¨æ¬¡æ•°è®¡æ•°å™¨
  143   1          static uint8 is_initialized = 0; // åˆå§‹åŒ–æ ‡å¿—,åªåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶è¿›è¡Œå¤šæ¬¡é‡‡æ ·,åç»­
             -è°ƒç”¨æ—¶ä½¿ç”¨çœŸæ­£çš„é€’æ¨ç®—æ³•   
  144   1          uint16 a = 0, b = 0;
  145   1          
  146   1          // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆå§‹åŒ–
  147   1          if (!is_initialized)
  148   1          {
  149   2              // é‡ç½®ç´¯åŠ å™¨
  150   2              for(a = 0; a < i_num; a++)
  151   2              {
  152   3                  sum[a][0] = 0;
  153   3              }
  154   2              
  155   2              // å‰å‡ æ¬¡é‡‡é›†ï¼Œç´¯ç§¯è¶³å¤Ÿçš„æ•°æ®
  156   2              for(filter_index = 0; filter_index < times; filter_index++)
  157   2              {
  158   3                  for(b = 0; b < i_num; b++)
  159   3                  {
  160   4                      sum[b][0] += get_adc(b);  // é‡‡é›†ä¸€æ¬¡ADCå¹¶ç´¯åŠ 
  161   4                  }
  162   3                  delay_us(5); // æ·»åŠ çŸ­æš‚å»¶æ—¶æé«˜é‡‡æ ·ç¨³å®šæ€§
  163   3              }
  164   2              
  165   2              // è®¡ç®—åˆå§‹å¹³å‡å€¼
  166   2              for(a = 0; a < i_num; a++)
  167   2              {
  168   3                  adc_fliter_data[a][0] = sum[a][0] / times;  // æ±‚å¹³å‡
  169   3                  result[a] = adc_fliter_data[a][0];
  170   3              }
  171   2              
  172   2              is_initialized = 1; // æ ‡è®°åˆå§‹åŒ–å®Œæˆ
  173   2          }
  174   1          else  // å·²åˆå§‹åŒ–ï¼Œæ‰§è¡Œé€’æ¨å‡å€¼æ»¤æ³¢
  175   1          {
  176   2              for(a = 0; a < i_num; a++)
  177   2              {
  178   3                  // é€’æ¨å‡å€¼æ»¤æ³¢æ ¸å¿ƒç®—æ³•ï¼šå‡å»å¹³å‡å€¼ï¼ŒåŠ ä¸Šæ–°å€¼ï¼Œé‡æ–°è®¡ç®—å¹³å‡å€¼
  179   3                  sum[a][0] -= (sum[a][0] / times);         // æ¯æ¬¡å»é™¤å¹³å‡å€¼çš„è´¡çŒ®
  180   3                  sum[a][0] += get_adc(a);              // åŠ ä¸Šæ–°å€¼
  181   3                  adc_fliter_data[a][0] = (sum[a][0] / times);  // æ±‚æ–°çš„å¹³å‡å€¼
  182   3                  result[a] = adc_fliter_data[a][0];      // ä¿å­˜ç»“æœ
  183   3              }
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 4   

  184   2          }
  185   1      }
  186          
  187          
  188          //-----------------------------------------------------------------------------
  189          // @brief   ä¸­ä½å€¼æ»¤æ³¢ï¼Œå°†æ¯ä¸ªç”µæ„Ÿçš„ä¸­ä½æ•°ä½œä¸ºç»“æœ
  190          // @param   æ— 
  191          // @return  æ— 
  192          // @author  ZP
  193          // Sample usage: mid_filter();
  194          //-----------------------------------------------------------------------------
  195          static uint8 mid_initialized = 0;  // ä¸­ä½å€¼æ»¤æ³¢åˆå§‹åŒ–æ ‡å¿—
  196          static uint16 sample_count = 0;    // é‡‡æ ·è®¡æ•°å™¨
  197          
  198          void mid_filter(void)
  199          {
  200   1          uint16 temp = 0, a = 0, t = 0;
  201   1          uint16 mid_index = 0;  //ä¸­ä½æ•°
  202   1        uint16 i = 0; //ç”¨äºå¾ªç¯
  203   1          // åˆ›å»ºä¸´æ—¶æ•°ç»„ç”¨äºæ’åºï¼Œé¿å…ä¿®æ”¹åŸå§‹æ•°æ®
  204   1          uint16 sort_array[HISTORY_COUNT];  // ä½¿ç”¨å®å®šä¹‰çš„å¸¸é‡è€Œä¸æ˜¯å˜é‡
  205   1        
  206   1          // è°ƒç”¨å‡å€¼æ»¤æ³¢è·å–æ–°çš„é‡‡æ ·å€¼
  207   1          average_filter();
  208   1          
  209   1          // å¦‚æœå°šæœªåˆå§‹åŒ–å®Œæˆ
  210   1          if (!mid_initialized)
  211   1          {
  212   2              // å°†å½“å‰æ»¤æ³¢ç»“æœå­˜å…¥å†å²æ•°ç»„
  213   2              for(a = 0; a < i_num; a++)
  214   2              {
  215   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  216   3                  result[a] = adc_fliter_data[a][0];
  217   3              }
  218   2              
  219   2              sample_count++;
  220   2              
  221   2              // å½“é‡‡é›†åˆ°è¶³å¤Ÿæ ·æœ¬æ—¶ï¼Œæ ‡è®°åˆå§‹åŒ–å®Œæˆ
  222   2              if (sample_count >= times)
  223   2              {
  224   3                  mid_initialized = 1;
  225   3                  sample_count = 0;  // é‡ç½®è®¡æ•°å™¨ç”¨äºå¾ªç¯ç¼“å†²
  226   3              }
  227   2          }
  228   1          else  // å·²åˆå§‹åŒ–ï¼Œæ‰§è¡Œä¸­ä½å€¼æ»¤æ³¢
  229   1          {
  230   2              // æ›´æ–°å†å²æ•°æ®æ•°ç»„
  231   2              for(a = 0; a < i_num; a++)
  232   2              {
  233   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  234   3              }
  235   2              
  236   2              // æ›´æ–°å¾ªç¯ç¼“å†²åŒºç´¢å¼•
  237   2              sample_count = (sample_count + 1) % times;
  238   2              
  239   2              // å¯¹æ¯ä¸ªç”µæ„Ÿé€šé“è¿›è¡Œå¤„ç†
  240   2              for(a = 0; a < i_num; a++)
  241   2              {
  242   3                  for(t = 0; t < times; t++)
  243   3                  {
  244   4                      sort_array[t] = adc_fliter_data[a][t];
  245   4                  }
  246   3                  
  247   3                  // å†’æ³¡æ’åº
  248   3                  for(i = 0; i < times-1; i++)
  249   3                  {
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 5   

  250   4                      for(t = 0; t < times-i-1; t++)
  251   4                      {
  252   5                          if(sort_array[t] > sort_array[t+1])
  253   5                          {
  254   6                              temp = sort_array[t];
  255   6                              sort_array[t] = sort_array[t+1];
  256   6                              sort_array[t+1] = temp;
  257   6                          }
  258   5                      }
  259   4                  }
  260   3                  
  261   3                  // è®¡ç®—ä¸­ä½æ•°ç´¢å¼•
  262   3                  mid_index = times / 2;  // 5 / 2 = 2  ,sort_array[2]æ˜¯ç¬¬ä¸‰ä¸ªæ•°å³ä¸­ä½æ•°
  263   3                  
  264   3                  // å–ä¸­ä½æ•°ä½œä¸ºç»“æœ
  265   3                  result[a] = sort_array[mid_index];
  266   3              }
  267   2          }
  268   1      }
  269          
  270          
  271          //-----------------------------------------------------------------------------
  272          // @brief   æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡†
  273          // @param   æ— 
  274          // @return  æ— 
  275          // @author  ZP
  276          // Sample usage: update_min_max_values();
  277          //-----------------------------------------------------------------------------
  278          void update_min_max_values(void)
  279          {
  280   1          uint8 i;
  281   1          static uint16 update_counter = 0;
  282   1          
  283   1          // å®šæœŸè½»å¾®è¡°å‡æœ€å¤§æœ€å°å€¼ï¼Œä½¿ç³»ç»Ÿèƒ½é€‚åº”ç¯å¢ƒå˜åŒ–
  284   1          update_counter++;
  285   1          if(update_counter >= 1000)  // æ¯1000æ¬¡è°ƒç”¨æ‰§è¡Œä¸€æ¬¡è¡°å‡
  286   1          {
  287   2              update_counter = 0;
  288   2              
  289   2              // æœ€å°å€¼ç•¥å¾®å¢åŠ ï¼Œæœ€å¤§å€¼ç•¥å¾®å‡å°‘ï¼Œå½¢æˆç¼“æ…¢è¡°å‡
  290   2              for(i = 0; i < SENSOR_COUNT; i++)
  291   2              {
  292   3                  // æœ€å°å€¼å‘ä¸Šè¡°å‡ï¼ˆå¢åŠ 1%ï¼‰
  293   3                  min_value[i] += min_value[i] / 100;
  294   3                  
  295   3                  // æœ€å¤§å€¼å‘ä¸‹è¡°å‡ï¼ˆå‡å°‘1%ï¼‰
  296   3                  if(max_value[i] > min_value[i])  // ç¡®ä¿æœ€å¤§å€¼å§‹ç»ˆå¤§äºæœ€å°å€¼
  297   3                      max_value[i] -= max_value[i] / 100;
  298   3              }
  299   2          }
  300   1          
  301   1          // æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å°å€¼å’Œæœ€å¤§å€¼
  302   1          for(i = 0; i < SENSOR_COUNT; i++)
  303   1          {
  304   2              // å¼‚å¸¸å€¼æ£€æµ‹ - å¦‚æœè¯»æ•°å¼‚å¸¸å¤§æˆ–å¼‚å¸¸å°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœï¼Œä¸æ›´æ–°
  305   2              if(result[i] > 1000 || result[i] < 5)
  306   2                  continue;
  307   2                  
  308   2              // æ›´æ–°æœ€å°å€¼ï¼ˆå¿½ç•¥è¿‡å°çš„å€¼ï¼Œå¯èƒ½æ˜¯å™ªå£°ï¼‰
  309   2              if(result[i] < min_value[i] && result[i] > 10) 
  310   2                  min_value[i] = result[i];
  311   2              
  312   2              // æ›´æ–°æœ€å¤§å€¼
  313   2              if(result[i] > max_value[i]) 
  314   2                  max_value[i] = result[i];
  315   2          }
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 6   

  316   1          
  317   1          // ç¡®ä¿æœ€å¤§æœ€å°å€¼ä¹‹é—´æœ‰è¶³å¤Ÿå·®è·ï¼Œé¿å…é™¤ä»¥æ¥è¿‘0çš„å€¼
  318   1          for(i = 0; i < SENSOR_COUNT; i++)
  319   1          {
  320   2              if(max_value[i] - min_value[i] < 20)
  321   2              {
  322   3                  // å¦‚æœå·®è·å¤ªå°ï¼Œå¼ºåˆ¶è®¾ç½®ä¸€ä¸ªåˆç†å·®è·
  323   3                  max_value[i] = min_value[i] + 20;
  324   3              }
  325   2          }
  326   1      }
  327          
  328          //-----------------------------------------------------------------------------
  329          // @brief   å½’ä¸€åŒ–ç”µæ„Ÿæ•°æ®
  330          // @param   æ— 
  331          // @return  æ— 
  332          // @author  ZP
  333          // Sample usage: normalize_sensors();
  334          //-----------------------------------------------------------------------------
  335          void normalize_sensors(void)
  336          {
  337   1          uint8 i;
  338   1          // å¯é€‰ï¼šå¯¹å½’ä¸€åŒ–åçš„æ•°æ®è¿›è¡Œå¹³æ»‘å¤„ç†ï¼Œå‡å°‘æŠ–åŠ¨
  339   1          static float last_normalized[SENSOR_COUNT] = {0};
  340   1          // å¹³æ»‘å› å­ï¼Œå¯è°ƒæ•´ï¼šå€¼è¶Šå¤§ï¼Œå“åº”è¶Šå¿«ä½†æŠ–åŠ¨è¶Šæ˜æ˜¾ï¼Œå€¼è¶Šå°ï¼Œå“åº”è¶Šæ…¢ä½
             -†æ›´å¹³ç¨³
  341   1          float smooth_factor = 0.7f; // å»ºè®®åœ¨0.6-0.8èŒƒå›´å†…è°ƒæ•´ï¼Œæ ¹æ®å°è½¦å®é™…è¡¨ç°å¾®è°ƒ    //
             - é¦–å…ˆæ›´æ–°æœ€å¤§æœ€å°å€¼
  342   1      
  343   1          // update_min_max_values();
  344   1          
  345   1          // å¯¹æ¯ä¸ªç”µæ„Ÿè¿›è¡Œå½’ä¸€åŒ–å¤„ç†
  346   1          for(i = 0; i < SENSOR_COUNT; i++)
  347   1          {
  348   2              // æ£€æŸ¥æœ€å¤§æœ€å°å€¼å·®å¼‚æ˜¯å¦è¶³å¤Ÿå¤§ï¼Œé˜²æ­¢é™¤ä»¥æ¥è¿‘0çš„å€¼
  349   2              if(max_value[i] - min_value[i] > 20) 
  350   2              {
  351   3                  // æ ‡å‡†çº¿æ€§å½’ä¸€åŒ–ï¼Œå°†å€¼æ˜ å°„åˆ°0-100èŒƒå›´ï¼ˆä¹˜ä»¥100æ–¹ä¾¿åç»­ä½¿ç”¨ï¼‰
  352   3                  normalized_data[i] = (float)(result[i] - min_value[i]) * 100.0f / (max_value[i] - min_value[i
             -]);
  353   3                  
  354   3                  // å¯é€‰ï¼šä½¿ç”¨å¹³æ–¹æ ¹éçº¿æ€§æ˜ å°„ï¼Œå¢å¼ºå°ä¿¡å·å“åº”(å¦‚æœå‘ç°å°è½¦å¯¹å°å
             -å·®ååº”ä¸æ•æ„Ÿï¼Œå¯ä»¥å–æ¶ˆå¹³æ–¹æ ¹æ˜ å°„çš„æ³¨é‡Š)
  355   3                  // normalized_data[i] = sqrtf(normalized_data[i] / 100.0f) * 100.0f;
  356   3              }
  357   2              else 
  358   2              {
  359   3                  // å¦‚æœæœ€å¤§æœ€å°å€¼å·®å¼‚å¤ªå°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœæˆ–æœªæ­£ç¡®åˆå§‹åŒ–
  360   3                  // ä½¿ç”¨åŸå§‹å€¼çš„ç›¸å¯¹æ¯”ä¾‹ä½œä¸ºæ›¿ä»£ï¼Œä¹Ÿä¹˜ä»¥100ä¿æŒä¸€è‡´æ€§
  361   3                  normalized_data[i] = (float)result[i] / 10.0f;  // å‡è®¾ADCæœ€å¤§å€¼ä¸º1000ï¼Œå½’ä¸€åŒ–åˆ°0-
             -100
  362   3              }
  363   2              
  364   2              // é™åˆ¶èŒƒå›´åœ¨0-100ä¹‹é—´
  365   2              if(normalized_data[i] > 100.0f) normalized_data[i] = 100.0f;
  366   2              if(normalized_data[i] < 0.0f) normalized_data[i] = 0.0f;
  367   2          }
  368   1          
  369   1          for(i = 0; i < SENSOR_COUNT; i++)
  370   1          {
  371   2              // ä½é€šæ»¤æ³¢å¹³æ»‘å¤„ç†
  372   2              normalized_data[i] = normalized_data[i] * smooth_factor + 
  373   2                                  last_normalized[i] * (1.0f - smooth_factor);
  374   2              
  375   2              // ä¿å­˜å½“å‰å€¼ç”¨äºä¸‹æ¬¡å¹³æ»‘
  376   2              last_normalized[i] = normalized_data[i];
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 7   

  377   2          }
  378   1      }
  379          
  380          //-----------------------------------------------------------------------------
  381          // @brief   æ”¹è¿›ç‰ˆè®¡ç®—ä½ç½®ï¼ˆä½¿ç”¨è‡ªé€‚åº”å·®æ¯”å’ŒåŠ æƒæ–¹æ³•ï¼‰
  382          // @param   æ— 
  383          // @return  è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼ï¼ŒèŒƒå›´-100åˆ°100
  384          // @author  ZP
  385          // Sample usage: position = calculate_position_improved();
  386          //-----------------------------------------------------------------------------
  387          int16 calculate_position_improved(void)
  388          {
  389   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
  390   1          float weight_outer = 0.15f;   // å¤–ä¾§ç”µæ„Ÿæƒé‡(HLå’ŒHR)
  391   1          float weight_middle = 0.40f;  // ä¸­é—´ç”µæ„Ÿæƒé‡(HMLå’ŒHMR)
  392   1          float weight_vertical = 0.15f; // çºµå‘ç”µæ„Ÿæƒé‡(VLå’ŒVR)
  393   1          float weight_center = 0.0f;  // ä¸­å¿ƒç”µæ„Ÿæƒé‡(HC)(æ²¡ç”¨ä¸Š)
  394   1          
  395   1          float diff_outer = 0;        // å¤–ä¾§ç”µæ„Ÿå·®å€¼
  396   1          float diff_middle = 0;       // ä¸­é—´ç”µæ„Ÿå·®å€¼
  397   1          float diff_vertical = 0;     // çºµå‘ç”µæ„Ÿå·®å€¼
  398   1          
  399   1          float sum_outer = 0;         // å¤–ä¾§ç”µæ„Ÿå’Œå€¼
  400   1          float sum_middle = 0;        // ä¸­é—´ç”µæ„Ÿå’Œå€¼
  401   1          float sum_vertical = 0;      // çºµå‘ç”µæ„Ÿå’Œå€¼
  402   1          float center_value = 0;      // ä¸­é—´ç”µæ„Ÿå€¼
  403   1          
  404   1          float ratio_outer = 0;       // å¤–ä¾§ç”µæ„Ÿå·®æ¯”å’Œ
  405   1          float ratio_middle = 0;      // ä¸­é—´ç”µæ„Ÿå·®æ¯”å’Œ
  406   1          float ratio_vertical = 0;    // çºµå‘ç”µæ„Ÿå·®æ¯”å’Œ
  407   1          
  408   1          float signal_strength = 0;   // ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  409   1          static int16 last_pos = 0;   // ä¸Šä¸€æ¬¡ä½ç½®å€¼ï¼Œç”¨äºæ»¤æ³¢
  410   1          static int16 very_last_pos = 0;  // ä¸Šä¸Šæ¬¡ä½ç½®å€¼ï¼Œç”¨äºäºŒæ¬¡æ»¤æ³¢
  411   1          static int16 very_very_last_pos = 0;  // ä¸Šä¸Šä¸Šæ¬¡ä½ç½®å€¼ï¼Œç”¨äºä¸‰æ¬¡æ»¤æ³¢
  412   1          int16 pos = 0;               // å½“å‰è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼
  413   1          static int16 max_change_rate = 8; // å…è®¸çš„æœ€å¤§å˜åŒ–ç‡ï¼Œè¶Šå¤§è¶Šçµæ•
  414   1          int16 position_change = 0;   // ä½ç½®å˜åŒ–é‡
  415   1        
  416   1        
  417   1        
  418   1        
  419   1        // ä½ç½®è®¡ç®—ï¼ˆåŒ…å«ä¸­å¿ƒç”µæ„Ÿçš„è´¡çŒ®ï¼‰
  420   1          // ä¸­å¿ƒç”µæ„Ÿè¶Šå¤§ï¼Œä½ç½®è¶Šæ¥è¿‘ä¸­å¿ƒçº¿ï¼Œè¿™é‡Œç›´æ¥å°†ä¸­å¿ƒç”µæ„Ÿä½œä¸ºä½ç½®ä¿®æ­£å› å­
             -
  421   1          float center_correction = 0;
  422   1          
  423   1          // è®¡ç®—å„å¯¹ç”µæ„Ÿçš„å·®å€¼å’Œå’Œå€¼
  424   1          diff_outer = normalized_data[SENSOR_HL] - normalized_data[SENSOR_HR];
  425   1          sum_outer = normalized_data[SENSOR_HL] + normalized_data[SENSOR_HR];
  426   1          
  427   1          diff_middle = normalized_data[SENSOR_HML] - normalized_data[SENSOR_HMR];
  428   1          sum_middle = normalized_data[SENSOR_HML] + normalized_data[SENSOR_HMR];
  429   1          
  430   1          diff_vertical = normalized_data[SENSOR_VL] - normalized_data[SENSOR_VR];
  431   1          sum_vertical = normalized_data[SENSOR_VL] + normalized_data[SENSOR_VR];
  432   1          
  433   1          // è·å–ä¸­é—´ç”µæ„Ÿå€¼
  434   1          center_value = normalized_data[SENSOR_HC];
  435   1          
  436   1          // è®¡ç®—ä¿¡å·å¼ºåº¦æŒ‡æ ‡ - æ‰€æœ‰ç”µæ„Ÿå¹³å‡å€¼
  437   1          signal_strength = (sum_outer + sum_middle + sum_vertical + center_value) / 7.0f;
  438   1          signal_strength_value = signal_strength; // ä¿å­˜ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  439   1      
  440   1      
  441   1      
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 8   

  442   1      
  443   1          // è®¡ç®—å·®æ¯”å’Œï¼Œä½¿ç”¨å¹³æ»‘è¿‡æ¸¡å‡½æ•°ä»£æ›¿ç¡¬é˜ˆå€¼ï¼Œé¿å…åœ¨ä¸´ç•Œå€¼é™„è¿‘äº§ç”Ÿè·³å˜
  444   1          // å¤–ä¾§ç”µæ„Ÿå¹³æ»‘è¿‡æ¸¡
  445   1          if(sum_outer > 16.0f)
  446   1              ratio_outer = diff_outer / sum_outer;
  447   1          else if(sum_outer < 3.0f)
  448   1              ratio_outer = 0;
  449   1          else
  450   1              ratio_outer = (diff_outer / sum_outer) * (sum_outer - 3.0f) / 7.0f; // 5-12èŒƒå›´å†…çº¿æ€§è¿‡æ¸¡
  451   1              
  452   1          // ä¸­é—´ç”µæ„Ÿå¹³æ»‘è¿‡æ¸¡
  453   1          if(sum_middle > 16.0f)
  454   1              ratio_middle = diff_middle / sum_middle;
  455   1          else if(sum_middle < 3.0f)
  456   1              ratio_middle = 0;
  457   1          else
  458   1              ratio_middle = (diff_middle / sum_middle) * (sum_middle - 3.0f) / 7.0f; // 5-12èŒƒå›´å†…çº¿æ€§è¿‡
             -æ¸¡
  459   1          
  460   1          // çºµå‘ç”µæ„Ÿå¹³æ»‘è¿‡æ¸¡
  461   1          if(sum_vertical > 16.0f)
  462   1              ratio_vertical = diff_vertical / sum_vertical;
  463   1          else if(sum_vertical < 3.0f)
  464   1              ratio_vertical = 0;
  465   1          else
  466   1              ratio_vertical = (diff_vertical / sum_vertical) * (sum_vertical - 3.0f) / 7.0f; // 5-12èŒƒå›´å†…ç
             -º¿æ€§è¿‡æ¸¡
  467   1          
  468   1        
  469   1        
  470   1        
  471   1          // èµ›é“ç±»å‹è¯†åˆ« - æ ¹æ®ä¸ƒç”µæ„Ÿç‰¹å¾åˆ¤æ–­
  472   1          if (track_type == WEIGHT_STRAIGHT) // 0. å½“å‰è®¤ä¸ºæ˜¯æ™®é€šèµ›é“æ—¶ï¼Œå°è¯•åˆ¤æ–­ç‰¹æ®Šèµ›é“
  473   1          {    
  474   2              // 1. ç›´è§’å¼¯é“ç‰¹å¾
  475   2              if(((normalized_data[SENSOR_HL] > 15.0f && normalized_data[SENSOR_VL] > 65.0f && 
  476   2                      normalized_data[SENSOR_HR] < 35.0f && normalized_data[SENSOR_VR] < 20.0f) ||
  477   2                      (normalized_data[SENSOR_VR] > 70.0f && 
  478   2                      normalized_data[SENSOR_HL] < 20.0f && normalized_data[SENSOR_VL] < 15.0f)) && 
  479   2                      normalized_data[SENSOR_HC] < 70.0f && 
  480   2                      signal_strength > 25.0f && signal_strength < 50.0f) // è°ƒæ•´ä¿¡å·å¼ºåº¦èŒƒå›´
  481   2              {
  482   3                  track_type = WEIGHT_RIGHT_ANGLE; // ç›´è§’å¼¯é“
  483   3              }
  484   2              else if((normalized_data[SENSOR_HC] > 95.0f && normalized_data[SENSOR_HML] > 80.0f && normalized_
             -data[SENSOR_HMR] > 60.0f && normalized_data[SENSOR_HR] > 70) ||  //å³ç¯å²›
  485   2                      (normalized_data[SENSOR_HC] > 90.0f && normalized_data[SENSOR_HML] > 50.0f && normalized_
             -data[SENSOR_HMR] > 60.0f && normalized_data[SENSOR_HL] > 70) && signal_strength > 50.0f)    // å·¦ç¯å²›
  486   2              {
  487   3                  track_type = 3;// ç¯å²›
  488   3              }
  489   2      
  490   2          else if (((normalized_data[SENSOR_HC] > 70 && normalized_data[SENSOR_HMR] > 75 && normalized_data[SENSO
             -R_HML] < 60 && normalized_data[SENSOR_VL] > 50 && normalized_data[SENSOR_VR] > 75) ||  //é€†æ—¶é’ˆ
  491   2                      (normalized_data[SENSOR_HC] > 80 && normalized_data[SENSOR_HML] > 80 && normalized_data[S
             -ENSOR_HMR] < 45 && normalized_data[SENSOR_VL] > 75 && normalized_data[SENSOR_VR] > 45)) && 
  492   2                      track_ten_flag == 1 && signal_strength > 50.0f ) 
  493   2          {
  494   3            track_type = 2; //åå­—åœ†ç¯
  495   3            track_ten_flag = 0; 
  496   3            ten_change_flag = 1;//æ„Ÿåº”åˆ°å…¥ç¯ï¼Œå»¶æ—¶2så†è®©track_ten_flag=1
  497   3            
  498   3          }
  499   2          }
  500   1          else if (track_type == WEIGHT_RIGHT_ANGLE) // 1. ç›´è§’å¼¯é“
  501   1        {
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 9   

  502   2          if (normalized_data[SENSOR_VL] > 60.0f && normalized_data[SENSOR_VR] < 20.0f )
  503   2          {
  504   3            track_type_zj = 1; //å·¦è½¬
  505   3            
  506   3          }
  507   2          else if (normalized_data[SENSOR_VR] > 70.0f && normalized_data[SENSOR_VL] < 20.0f )
  508   2          {
  509   3            track_type_zj = 2; //å³è½¬
  510   3          }
  511   2          
  512   2          if (track_type_zj != 0)
  513   2          {
  514   3                 // å›åˆ°ç›´é“ - å¯é€‰:å¢åŠ  signal_strength < 45.0f åˆ¤æ–­
  515   3            if (normalized_data[SENSOR_VR] < 20.0f && normalized_data[SENSOR_VL] < 20.0f ) 
  516   3            {
  517   4              track_type = WEIGHT_STRAIGHT; 
  518   4              track_type_zj = 0;
  519   4            }
  520   3            else if (signal_strength > 50) // ç›´è§’å³æ‹è¿›åœ†ç¯çš„ç‰¹æ®Šç‚¹
  521   3            {
  522   4              track_type = WEIGHT_ROUNDABOUT; 
  523   4              // track_type_zj = 0;
  524   4                // weight_outer = 0.4;  // æ¢æˆç›´é“çš„æƒ
  525   4                // weight_middle = 0.1;
  526   4                // weight_vertical = 0.1;
  527   4                // filter_param = track_weights[WEIGHT_STRAIGHT].filter_param;
  528   4                // max_change_rate = track_weights[WEIGHT_STRAIGHT].max_change_rate;
  529   4            }
  530   3          }
  531   2        }
  532   1          else if (track_type == WEIGHT_CROSS) // 2. åå­—åœ†ç¯
  533   1         {
  534   2              // å‡ºç¯  
  535   2          if (((normalized_data[SENSOR_HC] > 80 && normalized_data[SENSOR_HML] > 80 && normalized_data[SENSOR_VL]
             - > 80 && normalized_data[SENSOR_VR] > 70)  || //é€†æ—¶é’ˆ
  536   2                 (normalized_data[SENSOR_HC] > 80 && normalized_data[SENSOR_HMR] > 80 && normalized_data[SENSOR
             -_VL] > 70 && normalized_data[SENSOR_VR] > 80 )) &&
  537   2                  track_ten_flag == 1 && signal_strength > 50.0f )  //é¡ºæ—¶é’ˆ
  538   2                 {
  539   3                      track_type = WEIGHT_STRAIGHT; //å›ç›´é“
  540   3                track_ten_flag = 0;
  541   3                ten_change_flag = 1; //æ„Ÿåº”åˆ°å‡ºç¯å»¶æ—¶2så†è®©track_ten_flag=1
  542   3      
  543   3                 }
  544   2        }
  545   1          else if (track_type == WEIGHT_ROUNDABOUT) // 3. ç¯å²›   
  546   1          {
  547   2              if(normalized_data[SENSOR_HR] > 80.0f && normalized_data[SENSOR_HL] < 20.0f && track_route == 0)
  548   2              {
  549   3                  // å³ç¯å²›
  550   3                  track_route = 1;
  551   3            track_route_status = 1;
  552   3              }
  553   2              else if(normalized_data[SENSOR_HR] < 30.0f && normalized_data[SENSOR_HL] > 70.0f && track_route =
             -= 0)
  554   2              {
  555   3                  // å·¦ç¯å²›
  556   3                  track_route = 2;
  557   3            track_route_status = 1;
  558   3              }
  559   2          if(track_route_status == 2 &&((normalized_data[SENSOR_HMR] > 80.0f && normalized_data[SENSOR_HL] > 70.0
             -f && normalized_data[SENSOR_VL] > 65.0f && signal_strength > 50.0f) ||
  560   2              (normalized_data[SENSOR_HC] > 65.0f && normalized_data[SENSOR_HML] > 90.0f && normalized_data[SEN
             -SOR_VL] > 75.0f && normalized_data[SENSOR_HR] > 40.0f))) 
  561   2          {
  562   3      //      track_route = 0;
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 10  

  563   3            track_route_status = 3;
  564   3      //      track_type == WEIGHT_RIGHT_ANGLE; // æ£€éªŒä½ç‚¹
  565   3          }
  566   2          }
  567   1      
  568   1          // 4. è¶…å‡ºç½®0
  569   1         if(normalized_data[SENSOR_HC] < 2.0f && normalized_data[SENSOR_HMR] < 2.0f && normalized_data[SENSOR_H
             -ML] < 2.0f)
  570   1         {
  571   2             track_type = WEIGHT_STRAIGHT;
  572   2             track_route = 0;
  573   2             track_route_status = 0;
  574   2           track_type_zj = 0;
  575   2         }
  576   1          
  577   1          // æ ¹æ®èµ›é“ç±»å‹å’Œä¿¡å·å¼ºåº¦è°ƒæ•´æƒé‡
  578   1         switch(track_type)
  579   1         {
  580   2             case WEIGHT_STRAIGHT: // æ™®é€šèµ›é“
  581   2                 // ä½¿ç”¨ç›´é“æƒé‡
  582   2                 weight_outer = track_weights[WEIGHT_STRAIGHT].weight_outer;
  583   2                 weight_middle = track_weights[WEIGHT_STRAIGHT].weight_middle;
  584   2                 weight_vertical = track_weights[WEIGHT_STRAIGHT].weight_vertical;
  585   2                 filter_param = track_weights[WEIGHT_STRAIGHT].filter_param;
  586   2                 max_change_rate = track_weights[WEIGHT_STRAIGHT].max_change_rate;
  587   2                 break;
  588   2                 
  589   2             case WEIGHT_RIGHT_ANGLE: // ç›´è§’å¼¯é“
  590   2                 // ä½¿ç”¨ç›´è§’å¼¯é“æƒé‡
  591   2                 weight_outer = track_weights[WEIGHT_RIGHT_ANGLE].weight_outer;
  592   2                 weight_middle = track_weights[WEIGHT_RIGHT_ANGLE].weight_middle;
  593   2                 weight_vertical = track_weights[WEIGHT_RIGHT_ANGLE].weight_vertical;
  594   2                 filter_param = track_weights[WEIGHT_RIGHT_ANGLE].filter_param;
  595   2                 max_change_rate = track_weights[WEIGHT_RIGHT_ANGLE].max_change_rate;
  596   2                 break;
  597   2                 
  598   2             case WEIGHT_CROSS: // åå­—åœ†ç¯
  599   2                 // ä½¿ç”¨åå­—åœ†ç¯æƒé‡
  600   2                 weight_outer = track_weights[WEIGHT_CROSS].weight_outer;
  601   2                 weight_middle = track_weights[WEIGHT_CROSS].weight_middle;
  602   2                 weight_vertical = track_weights[WEIGHT_CROSS].weight_vertical;
  603   2                 filter_param = track_weights[WEIGHT_CROSS].filter_param;
  604   2                 max_change_rate = track_weights[WEIGHT_CROSS].max_change_rate;
  605   2                 break;
  606   2                 
  607   2             case WEIGHT_ROUNDABOUT: // ç¯å²›
  608   2                 // ä½¿ç”¨ç¯å²›æƒé‡
  609   2                 weight_outer = track_weights[WEIGHT_ROUNDABOUT].weight_outer;
  610   2                 weight_middle = track_weights[WEIGHT_ROUNDABOUT].weight_middle;
  611   2                 weight_vertical = track_weights[WEIGHT_ROUNDABOUT].weight_vertical;
  612   2                 filter_param = track_weights[WEIGHT_ROUNDABOUT].filter_param;
  613   2                 max_change_rate = track_weights[WEIGHT_ROUNDABOUT].max_change_rate;
  614   2                 break;
  615   2      
  616   2             default:
  617   2                 // ä½¿ç”¨é»˜è®¤çš„ç›´é“æƒé‡
  618   2                 weight_outer = track_weights[WEIGHT_STRAIGHT].weight_outer;
  619   2                 weight_middle = track_weights[WEIGHT_STRAIGHT].weight_middle;
  620   2                 weight_vertical = track_weights[WEIGHT_STRAIGHT].weight_vertical;
  621   2                 filter_param = track_weights[WEIGHT_STRAIGHT].filter_param;
  622   2                 max_change_rate = track_weights[WEIGHT_STRAIGHT].max_change_rate;
  623   2                 break;
  624   2         }
  625   1          
  626   1          // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå½“æ‰€æœ‰ç”µæ„Ÿå€¼éƒ½å¾ˆå°æ—¶ï¼Œå¯èƒ½å·²ç»åç¦»èµ›é“
  627   1      //    if(sum_outer < 10.0f && sum_middle < 10.0f && sum_vertical < 10.0f && center_value < 10.0f)
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 11  

  628   1      //    {
  629   1      //        // æ ¹æ®ä¸Šä¸€æ¬¡ä½ç½®åˆ¤æ–­åç¦»æ–¹å‘
  630   1      //        if(last_pos > 0)
  631   1      //            return 100;  // å‘å³åç¦»
  632   1      //        else
  633   1      //            return -100; // å‘å·¦åç¦»
  634   1      //    }
  635   1          
  636   1          // å½“ä¸­å¿ƒç”µæ„Ÿå¤§äºé˜ˆå€¼æ—¶ï¼Œè®¤ä¸ºè½¦è¾†æ¥è¿‘ä¸­å¿ƒï¼Œå¯¹ä½ç½®è¿›è¡Œä¿®æ­£
  637   1          if(center_value > 50.0f) {
  638   2              // ä¿®æ­£ç³»æ•°ï¼Œå½“ä¸­å¿ƒç”µæ„Ÿå¼ºåº¦é«˜æ—¶ï¼Œä¿®æ­£ç³»æ•°å¤§
  639   2              center_correction = (center_value - 40.0f) / 60.0f * 0.5f;  // æœ€å¤§ä¿®æ­£50%
  640   2          }
  641   1          
  642   1          // ä¸‰ç»„å·®æ¯”å’ŒåŠ æƒå¹³å‡è®¡ç®—ä½ç½®
  643   1          pos = (int16)((ratio_outer * weight_outer + 
  644   1                         ratio_middle * weight_middle + 
  645   1                         ratio_vertical * weight_vertical) * 100.0f);
  646   1          
  647   1          // åº”ç”¨ä¸­å¿ƒç”µæ„Ÿä¿®æ­£ - å‘ä¸­å¿ƒçº¿æ‹‰è¿‘
  648   1          pos = (int16)(pos * (1.0f - center_correction));
  649   1          
  650   1          // é™åˆ¶èŒƒå›´åœ¨-100åˆ°100ä¹‹é—´
  651   1          if(pos > 100) pos = 100;
  652   1          if(pos < -100) pos = -100;
  653   1          
  654   1          // ä½ç½®å˜åŒ–é‡é™åˆ¶ï¼Œé˜²æ­¢çªå˜
  655   1          position_change = pos - last_pos;
  656   1          if(position_change > max_change_rate)
  657   1              pos = last_pos + max_change_rate;
  658   1          else if(position_change < -max_change_rate)
  659   1              pos = last_pos - max_change_rate;
  660   1          
  661   1          // åº”ç”¨ä½é€šæ»¤æ³¢ï¼Œå¹³æ»‘ä½ç½®å˜åŒ–
  662   1          pos = (int16)(filter_param * pos + (1-filter_param) * last_pos);
  663   1          
  664   1          // å¦‚æœä¿¡å·å¼ºåº¦é«˜ï¼Œå¢å¼ºæ»¤æ³¢æ•ˆæœ
  665   1          if(signal_strength > 60.0f) {
  666   2              // åº”ç”¨ä¸‰ç‚¹å¹³å‡æ»¤æ³¢ï¼Œè¿›ä¸€æ­¥å¹³æ»‘
  667   2              pos = (pos + last_pos + very_last_pos) / 3;
  668   2          }
  669   1          
  670   1          // æ›´æ–°å†å²ä½ç½®å€¼
  671   1          very_very_last_pos = very_last_pos;
  672   1          very_last_pos = last_pos;
  673   1          last_pos = pos;
  674   1          
  675   1          return pos;
  676   1      }
  677          
  678          
  679          //-----------------------------------------------------------------------------
  680          // @brief   ç”µç£ä¿æŠ¤é€»è¾‘å‡½æ•°
  681          // @param   æ— 
  682          // @return  ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  683          // @author  ZP
  684          // Sample usage: protection_flag = check_electromagnetic_protection();
  685          //-----------------------------------------------------------------------------
  686          uint8 check_electromagnetic_protection(void)
  687          {
  688   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
  689   1          uint8 is_out_of_track = 0;    // æ ‡è®°æ˜¯å¦è„±ç¦»èµ›é“çš„æ ‡å¿—ä½
  690   1          uint16 sum_value = 0;         // æ‰€æœ‰ç”µæ„Ÿå€¼çš„æ€»å’Œ
  691   1          uint16 threshold = 175;       // é˜ˆå€¼ï¼Œéœ€è¦æ ¹æ®ä¸ƒç”µæ„Ÿçš„å®é™…æƒ…å†µè°ƒæ•´ï¼ˆå¢åŠ ï¼‰
  692   1          static uint8 out_of_track_count = 0;    // è¿ç»­æ£€æµ‹åˆ°è„±ç¦»èµ›é“çš„æ¬¡æ•°è®¡æ•°å™¨
  693   1          static uint8 in_track_count = 0;        // è¿ç»­æ£€æµ‹åˆ°åœ¨è½¨é“ä¸Šçš„æ¬¡æ•°è®¡æ•°å™¨
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 12  

  694   1          static uint8 protection_triggered = 0;  // ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  695   1          uint8 i;
  696   1          uint8 trigger_reason = 0;     // è®°å½•è§¦å‘åŸå› ï¼Œç”¨äºè°ƒè¯•
  697   1          
  698   1          if (startKeyFlag == 1)
  699   1        {
  700   2          // è®¡ç®—æ‰€æœ‰ç”µæ„Ÿçš„å’Œå€¼
  701   2          for(i = 0; i < SENSOR_COUNT; i++)
  702   2          {
  703   3            sum_value += result[i];
  704   3          }
  705   2          
  706   2          // åˆ¤æ–­æ˜¯å¦è„±ç¦»èµ›é“çš„æ¡ä»¶
  707   2          // 1. æ‰€æœ‰ç”µæ„Ÿå€¼æ€»å’Œè¿‡å°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
  708   2          if(sum_value < threshold)
  709   2          {
  710   3            is_out_of_track = 1;
  711   3            trigger_reason = 1;
  712   3          }
  713   2          
  714   2          // 2. å½’ä¸€åŒ–åçš„å€¼éƒ½å¾ˆå°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
  715   2          if(normalized_data[SENSOR_HL] < 5.0f && normalized_data[SENSOR_VL] < 5.0f && 
  716   2             normalized_data[SENSOR_HML] < 5.0f && normalized_data[SENSOR_HC] < 5.0f && 
  717   2             normalized_data[SENSOR_HMR] < 5.0f && normalized_data[SENSOR_VR] < 5.0f && 
  718   2             normalized_data[SENSOR_HR] < 5.0f)
  719   2          {
  720   3            is_out_of_track = 1;
  721   3            trigger_reason = 2;
  722   3          }
  723   2          
  724   2          // 3. ä½ç½®åå·®è¿‡å¤§ï¼Œè¯´æ˜å¯èƒ½åç¦»èµ›é“å¤ªå¤š
  725   2          if(position < -80 || position > 80)
  726   2          {
  727   3            // åªæœ‰å½“ç”µæ„Ÿå€¼æ€»å’Œä¹Ÿè¾ƒå°æ—¶æ‰åˆ¤æ–­ä¸ºå‡ºèµ›é“
  728   3            if(sum_value < threshold * 2)
  729   3            {
  730   4              is_out_of_track = 1;
  731   4              trigger_reason = 3;
  732   4            }
  733   3          }
  734   2          
  735   2          // // è¿ç»­æ£€æµ‹é€»è¾‘ï¼Œé˜²æ­¢å¶ç„¶çš„ä½å€¼å¯¼è‡´è¯¯åˆ¤
  736   2          if(is_out_of_track)
  737   2          {
  738   3            out_of_track_count++;
  739   3            in_track_count = 0;  // é‡ç½®åœ¨è½¨é“ä¸Šçš„è®¡æ•°
  740   3            
  741   3            if(out_of_track_count >= 5 && !protection_triggered)  // è¿ç»­5æ¬¡æ£€æµ‹åˆ°è„±ç¦»èµ›é“æ‰è§¦å‘ä¿æŠ
             -¤
  742   3            {
  743   4              protection_triggered = 1;
  744   4              // è¿™é‡Œå¯ä»¥è¾“å‡ºè§¦å‘ä¿æŠ¤çš„ä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•
  745   4        ////            sprintf(g_TxData, "Protection triggered! Reason: %d, Sum: %d\n", trigger_reason, sum_val
             -ue);
  746   4        ////            uart_putstr(UART_4, g_TxData);
  747   4            }
  748   3          }
  749   2          // else
  750   2          // {
  751   2          //     // å¦‚æœæ£€æµ‹æ­£å¸¸ï¼Œè®¡æ•°å™¨å¢åŠ 
  752   2          //     in_track_count++;
  753   2          //     if(out_of_track_count > 0)
  754   2          //         out_of_track_count--;
  755   2              
  756   2          //     // è‡ªåŠ¨æ¢å¤æœºåˆ¶ï¼šè¿ç»­20æ¬¡æ£€æµ‹åˆ°æ­£å¸¸ï¼Œåˆ™è§£é™¤ä¿æŠ¤çŠ¶æ€
  757   2          //     if(in_track_count >= 20 && protection_triggered)
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 13  

  758   2          //     {
  759   2          //         protection_triggered = 0;
  760   2          //         out_of_track_count = 0;
  761   2          //         in_track_count = 0;
  762   2          //         // å¯ä»¥è¾“å‡ºè‡ªåŠ¨æ¢å¤çš„ä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•
  763   2          //         // sprintf(g_TxData, "Protection auto reset!\n");
  764   2          //         // uart_putstr(UART_4, g_TxData);
  765   2          //     }
  766   2          // }
  767   2          
  768   2          return protection_triggered;
  769   2        }
  770   1        return 0;
  771   1      }
  772          
  773          
  774          
  775          // æ˜¾ç¤ºç”µç£ä¼ æ„Ÿå™¨æ•°æ®
  776          void display_electromagnetic_data(void)
  777          {
  778   1          // æ˜¾ç¤ºåŸå§‹æ»¤æ³¢æ•°æ®å’Œå½’ä¸€åŒ–æ•°æ®
  779   1          ips114_showstr_simspi(0,0,"HL:");   
  780   1          ips114_showuint16_simspi(3*8, 0, result[SENSOR_HL]);
  781   1          ips114_showstr_simspi(9*8,0,"N:");
  782   1          ips114_showfloat_simspi(11*8, 0, normalized_data[SENSOR_HL], 2, 2);
  783   1          
  784   1          ips114_showstr_simspi(0,1,"VL:");  
  785   1          ips114_showuint16_simspi(3*8, 1, result[SENSOR_VL]);
  786   1          ips114_showstr_simspi(9*8,1,"N:");
  787   1          ips114_showfloat_simspi(11*8, 1, normalized_data[SENSOR_VL], 2, 2);
  788   1          
  789   1          ips114_showstr_simspi(0,2,"HML:");  
  790   1          ips114_showuint16_simspi(4*8, 2, result[SENSOR_HML]);
  791   1          ips114_showstr_simspi(9*8,2,"N:");
  792   1          ips114_showfloat_simspi(11*8, 2, normalized_data[SENSOR_HML], 2, 2);
  793   1          
  794   1          ips114_showstr_simspi(0,3,"HC:");   
  795   1          ips114_showuint16_simspi(3*8, 3, result[SENSOR_HC]);
  796   1          ips114_showstr_simspi(9*8,3,"N:");
  797   1          ips114_showfloat_simspi(11*8, 3, normalized_data[SENSOR_HC], 2, 2);
  798   1          
  799   1          ips114_showstr_simspi(0,4,"HMR:");   
  800   1          ips114_showuint16_simspi(4*8, 4, result[SENSOR_HMR]);
  801   1          ips114_showstr_simspi(9*8,4,"N:");
  802   1          ips114_showfloat_simspi(11*8, 4, normalized_data[SENSOR_HMR], 2, 2);
  803   1          
  804   1          ips114_showstr_simspi(0,5,"VR:");   
  805   1          ips114_showuint16_simspi(3*8, 5, result[SENSOR_VR]);
  806   1          ips114_showstr_simspi(9*8,5,"N:");
  807   1          ips114_showfloat_simspi(11*8, 5, normalized_data[SENSOR_VR], 2, 2);
  808   1          
  809   1          ips114_showstr_simspi(0,6,"HR:");   
  810   1          ips114_showuint16_simspi(3*8, 6, result[SENSOR_HR]);
  811   1          ips114_showstr_simspi(9*8,6,"N:");
  812   1          ips114_showfloat_simspi(11*8, 6, normalized_data[SENSOR_HR], 2, 2);
  813   1          
  814   1          // æ˜¾ç¤ºä½ç½®å’Œå·®æ¯”å’Œæ•°æ®
  815   1          ips114_showstr_simspi(0,7,"Pos:");
  816   1          ips114_showint16_simspi(5*8, 7, position);
  817   1          
  818   1          // æ˜¾ç¤ºä¿æŠ¤çŠ¶æ€
  819   1          ips114_showstr_simspi(10*8,7,"P:");
  820   1          ips114_showuint8_simspi(12*8, 7, protection_flag);
  821   1      } 


C251 COMPILER V5.60.0,  electromagnetic_tracking                                           13/05/25  21:31:03  PAGE 14  

Module Information          Static   Overlayable
------------------------------------------------
  code size            =      6226     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       506     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       610     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
