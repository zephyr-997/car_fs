C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE electromagnetic_tracking
OBJECT MODULE PLACED IN .\Out_File\electromagnetic_tracking.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\electromagnetic_tracking.c XSMALL INTR2 FL
                    -OAT64 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree
                    -_libraries;..\seekfree_peripheral;..\libraries) DEBUG PRINT(.\Out_File\electromagnetic_tracking.lst) TABS(2) OBJECT(.\Ou
                    -t_File\electromagnetic_tracking.obj) 

stmt  level    source

    1          #include "electromagnetic_tracking.h"
    2          #include "headfile.h"
    3          #include "common.h"
    4          
    5          // æ»¤æ³¢åæ•°æ® - ä½¿ç”¨äºŒç»´æ•°ç»„å½¢å¼
    6          // ç¬¬ä¸€ç»´è¡¨ç¤ºç”µæ„Ÿç¼–å·ï¼š0-L, 1-LM, 2-RM, 3-R
    7          // ç¬¬äºŒç»´ä¿ç•™ï¼Œå¯ç”¨äºå­˜å‚¨å†å²æ•°æ®
    8          #define SENSOR_COUNT 4   //ç”µæ„Ÿä¸ªæ•°
    9          #define HISTORY_COUNT 5  //æ»¤æ³¢æ¬¡æ•°
   10          
   11          uint16 adc_fliter_data[SENSOR_COUNT][HISTORY_COUNT] = {0}; //æ»¤æ³¢åçš„å€¼
   12          float result[SENSOR_COUNT] = {0};   //ç”µå­˜å‚¨æ¯ä¸ªç”µæ„Ÿæ»¤æ³¢åçš„æœ€ç»ˆç»“æœå€¼ï¼ˆå°šæœªå½’ä¸€åŒ–ï¼
             -‰ï¼Œæ˜¯è¿æ¥æ»¤æ³¢å¤„ç†å’Œå½’ä¸€åŒ–å¤„ç†çš„ä¸­é—´å˜é‡
   13          uint16 sum[SENSOR_COUNT][HISTORY_COUNT] = {0};        //ç´¯åŠ çš„å’Œ
   14          
   15          // é€’æ¨å‡å€¼æ»¤æ³¢ç›¸å…³å‚æ•°
   16          uint16 times = HISTORY_COUNT;  // æ»¤æ³¢æ¬¡æ•°
   17          uint16 i_num = SENSOR_COUNT;  // ç”µæ„Ÿæ•°é‡
   18          
   19          // å½’ä¸€åŒ–æ•°æ® - æ”¹ä¸ºæ•°ç»„å½¢å¼
   20          float normalized_data[SENSOR_COUNT] = {0.0f, 0.0f, 0.0f, 0.0f};  // å½’ä¸€åŒ–åçš„ç”µæ„Ÿæ•°æ®æ•°ç»„
   21          
   22          // å­˜å‚¨æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡† - æ”¹ä¸ºæ•°ç»„å½¢å¼
   23          uint16 min_value[SENSOR_COUNT] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å°å€¼
   24          uint16 max_value[SENSOR_COUNT] = {0, 0, 0, 0};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§å€¼
   25          
   26          // ç”µæ„Ÿä½ç½®è®¡ç®—ç›¸å…³å˜é‡
   27          int16 position = 0;
   28          
   29          // ç”µç£ä¿æŠ¤é€»è¾‘å˜é‡
   30          uint8 protection_flag = 0;
   31          
   32          // å·®æ¯”å’Œç®—æ³•ä¸­é—´å˜é‡
   33          float ratio_L_R = 0;
   34          float ratio_LM_RM = 0;
   35          
   36          //-----------------------------------------------------------------------------
   37          // @brief   ç”µç£ä¼ æ„Ÿå™¨åˆå§‹åŒ–
   38          // @param   æ— 
   39          // @return  æ— 
   40          // @author  ZP
   41          // Sample usage: electromagnetic_init();
   42          //-----------------------------------------------------------------------------
   43          void electromagnetic_init(void)
   44          {
   45   1         uint8 i = 0, j = 0;
   46   1      
   47   1         adc_init(ADC_L, 0);
   48   1         adc_init(ADC_LM, 0);
   49   1         adc_init(ADC_RM, 0);
   50   1         adc_init(ADC_R, 0);
   51   1         
   52   1         // åˆå§‹åŒ–äºŒç»´æ•°ç»„
   53   1         for(i = 0; i < SENSOR_COUNT; i++)
   54   1         {
   55   2             for(j = 0; j < HISTORY_COUNT; j++)
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 2   

   56   2             {
   57   3                 adc_fliter_data[i][j] = 0;
   58   3                 sum[i][j] = 0;
   59   3             }
   60   2             normalized_data[i] = 0.0f;  // åˆå§‹åŒ–å½’ä¸€åŒ–æ•°æ®æ•°ç»„
   61   2         }
   62   1      }
   63          
   64          //-----------------------------------------------------------------------------
   65          // @brief   å¾—åˆ°adcçš„å€¼
   66          // @param   æµ‹çš„ADC/ç”µæ„Ÿåºå·
   67          // @return  æµ‹å‡ºçš„adcå€¼
   68          // @author  ZP
   69          // Sample usage: get_adc(1)
   70          //-----------------------------------------------------------------------------
   71          uint16 get_adc(uint16 i)
   72          {
   73   1        switch(i){
   74   2          case 0:
   75   2            return adc_once(ADC_L, ADC_10BIT);  //ADC_10BITæ˜¯ç”µç£å¯»è¿¹æœ€ä½³åˆ†è¾¨ç‡
   76   2          case 1:
   77   2            return adc_once(ADC_LM, ADC_10BIT);
   78   2          case 2:
   79   2            return adc_once(ADC_RM, ADC_10BIT);
   80   2          case 3:
   81   2            return adc_once(ADC_R, ADC_10BIT);
   82   2          default:
   83   2            return 0;
   84   2        }
   85   1      }
   86          
   87          //-----------------------------------------------------------------------------
   88          // @brief   é€’æ¨å‡å€¼æ»¤æ³¢
   89          // @param   æ— 
   90          // @return  æ— 
   91          // @author  zp
   92          // Sample usage: average_filter();
   93          //-----------------------------------------------------------------------------
   94          static uint16 filter_index = 0;  // é€’æ¨æ¬¡æ•°è®¡æ•°å™¨
   95          static uint8 is_initialized = 0; // åˆå§‹åŒ–æ ‡å¿—,åªåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶è¿›è¡Œå¤šæ¬¡é‡‡æ ·,åç»­è°ƒç
             -”¨æ—¶ä½¿ç”¨çœŸæ­£çš„é€’æ¨ç®—æ³•
   96          uint16 j = 0;
   97          
   98          void average_filter(void)
   99          {
  100   1          uint16 a = 0, b = 0;
  101   1          
  102   1          // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆå§‹åŒ–
  103   1          if (!is_initialized)
  104   1          {
  105   2              // é‡ç½®ç´¯åŠ å™¨
  106   2              for(a = 0; a < i_num; a++)
  107   2              {
  108   3                  sum[a][0] = 0;
  109   3              }
  110   2              
  111   2              // å‰å‡ æ¬¡é‡‡é›†ï¼Œç´¯ç§¯è¶³å¤Ÿçš„æ•°æ®
  112   2              for(filter_index = 0; filter_index < times; filter_index++)
  113   2              {
  114   3                  for(b = 0; b < i_num; b++)
  115   3                  {
  116   4                      sum[b][0] += get_adc(b);  // é‡‡é›†ä¸€æ¬¡ADCå¹¶ç´¯åŠ 
  117   4                  }
  118   3                  delay_us(5); // æ·»åŠ çŸ­æš‚å»¶æ—¶æé«˜é‡‡æ ·ç¨³å®šæ€§
  119   3              }
  120   2              
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 3   

  121   2              // è®¡ç®—åˆå§‹å¹³å‡å€¼
  122   2              for(a = 0; a < i_num; a++)
  123   2              {
  124   3                  adc_fliter_data[a][0] = sum[a][0] / times;  // æ±‚å¹³å‡
  125   3                  result[a] = adc_fliter_data[a][0];
  126   3              }
  127   2              
  128   2              is_initialized = 1; // æ ‡è®°åˆå§‹åŒ–å®Œæˆ
  129   2          }
  130   1          else  // å·²åˆå§‹åŒ–ï¼Œæ‰§è¡Œé€’æ¨å‡å€¼æ»¤æ³¢
  131   1          {
  132   2              for(a = 0; a < i_num; a++)
  133   2              {
  134   3                  // é€’æ¨å‡å€¼æ»¤æ³¢æ ¸å¿ƒç®—æ³•ï¼šå‡å»å¹³å‡å€¼ï¼ŒåŠ ä¸Šæ–°å€¼ï¼Œé‡æ–°è®¡ç®—å¹³å‡å€¼
  135   3                  sum[a][0] -= (sum[a][0] / times);         // æ¯æ¬¡å»é™¤å¹³å‡å€¼çš„è´¡çŒ®
  136   3                  sum[a][0] += get_adc(a);              // åŠ ä¸Šæ–°å€¼
  137   3                  adc_fliter_data[a][0] = (sum[a][0] / times);  // æ±‚æ–°çš„å¹³å‡å€¼
  138   3                  result[a] = adc_fliter_data[a][0];      // ä¿å­˜ç»“æœ
  139   3              }
  140   2          }
  141   1      }
  142          
  143          
  144          //-----------------------------------------------------------------------------
  145          // @brief   ä¸­ä½å€¼æ»¤æ³¢ï¼Œå°†æ¯ä¸ªç”µæ„Ÿçš„ä¸­ä½æ•°ä½œä¸ºç»“æœ
  146          // @param   æ— 
  147          // @return  æ— 
  148          // @author  ZP
  149          // Sample usage: mid_filter();
  150          //-----------------------------------------------------------------------------
  151          static uint8 mid_initialized = 0;  // ä¸­ä½å€¼æ»¤æ³¢åˆå§‹åŒ–æ ‡å¿—
  152          static uint16 sample_count = 0;    // é‡‡æ ·è®¡æ•°å™¨
  153          
  154          void mid_filter(void)
  155          {
  156   1          uint16 temp = 0, a = 0, t = 0;
  157   1          uint16 mid_index = 0;  //ä¸­ä½æ•°
  158   1        uint16 i = 0; //ç”¨äºå¾ªç¯
  159   1          // åˆ›å»ºä¸´æ—¶æ•°ç»„ç”¨äºæ’åºï¼Œé¿å…ä¿®æ”¹åŸå§‹æ•°æ®
  160   1          uint16 sort_array[HISTORY_COUNT];  // ä½¿ç”¨å®å®šä¹‰çš„å¸¸é‡è€Œä¸æ˜¯å˜é‡
  161   1        
  162   1          // è°ƒç”¨å‡å€¼æ»¤æ³¢è·å–æ–°çš„é‡‡æ ·å€¼
  163   1          average_filter();
  164   1          
  165   1          // å¦‚æœå°šæœªåˆå§‹åŒ–å®Œæˆ
  166   1          if (!mid_initialized)
  167   1          {
  168   2              // å°†å½“å‰æ»¤æ³¢ç»“æœå­˜å…¥å†å²æ•°ç»„
  169   2              for(a = 0; a < i_num; a++)
  170   2              {
  171   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  172   3                  result[a] = adc_fliter_data[a][0];
  173   3              }
  174   2              
  175   2              sample_count++;
  176   2              
  177   2              // å½“é‡‡é›†åˆ°è¶³å¤Ÿæ ·æœ¬æ—¶ï¼Œæ ‡è®°åˆå§‹åŒ–å®Œæˆ
  178   2              if (sample_count >= times)
  179   2              {
  180   3                  mid_initialized = 1;
  181   3                  sample_count = 0;  // é‡ç½®è®¡æ•°å™¨ç”¨äºå¾ªç¯ç¼“å†²
  182   3              }
  183   2          }
  184   1          else  // å·²åˆå§‹åŒ–ï¼Œæ‰§è¡Œä¸­ä½å€¼æ»¤æ³¢
  185   1          {
  186   2              // æ›´æ–°å†å²æ•°æ®æ•°ç»„
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 4   

  187   2              for(a = 0; a < i_num; a++)
  188   2              {
  189   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  190   3              }
  191   2              
  192   2              // æ›´æ–°å¾ªç¯ç¼“å†²åŒºç´¢å¼•
  193   2              sample_count = (sample_count + 1) % times;
  194   2              
  195   2              // å¯¹æ¯ä¸ªç”µæ„Ÿé€šé“è¿›è¡Œå¤„ç†
  196   2              for(a = 0; a < i_num; a++)
  197   2              {
  198   3                  for(t = 0; t < times; t++)
  199   3                  {
  200   4                      sort_array[t] = adc_fliter_data[a][t];
  201   4                  }
  202   3                  
  203   3                  // å†’æ³¡æ’åº
  204   3                  for(i = 0; i < times-1; i++)
  205   3                  {
  206   4                      for(t = 0; t < times-i-1; t++)
  207   4                      {
  208   5                          if(sort_array[t] > sort_array[t+1])
  209   5                          {
  210   6                              temp = sort_array[t];
  211   6                              sort_array[t] = sort_array[t+1];
  212   6                              sort_array[t+1] = temp;
  213   6                          }
  214   5                      }
  215   4                  }
  216   3                  
  217   3                  // è®¡ç®—ä¸­ä½æ•°ç´¢å¼•
  218   3                  mid_index = times / 2;  // 5 / 2 = 2  ,sort_array[2]æ˜¯ç¬¬ä¸‰ä¸ªæ•°å³ä¸­ä½æ•°
  219   3                  
  220   3                  // å–ä¸­ä½æ•°ä½œä¸ºç»“æœ
  221   3                  result[a] = sort_array[mid_index];
  222   3              }
  223   2          }
  224   1      }
  225          
  226          
  227          //-----------------------------------------------------------------------------
  228          // @brief   æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡†
  229          // @param   æ— 
  230          // @return  æ— 
  231          // @author  ZP
  232          // Sample usage: update_min_max_values();
  233          //-----------------------------------------------------------------------------
  234          void update_min_max_values(void)
  235          {
  236   1          uint8 i;
  237   1          static uint16 update_counter = 0;
  238   1          
  239   1          // å®šæœŸè½»å¾®è¡°å‡æœ€å¤§æœ€å°å€¼ï¼Œä½¿ç³»ç»Ÿèƒ½é€‚åº”ç¯å¢ƒå˜åŒ–
  240   1          update_counter++;
  241   1          if(update_counter >= 1000)  // æ¯1000æ¬¡è°ƒç”¨æ‰§è¡Œä¸€æ¬¡è¡°å‡
  242   1          {
  243   2              update_counter = 0;
  244   2              
  245   2              // æœ€å°å€¼ç•¥å¾®å¢åŠ ï¼Œæœ€å¤§å€¼ç•¥å¾®å‡å°‘ï¼Œå½¢æˆç¼“æ…¢è¡°å‡
  246   2              for(i = 0; i < SENSOR_COUNT; i++)
  247   2              {
  248   3                  // æœ€å°å€¼å‘ä¸Šè¡°å‡ï¼ˆå¢åŠ 1%ï¼‰
  249   3                  min_value[i] += min_value[i] / 100;
  250   3                  
  251   3                  // æœ€å¤§å€¼å‘ä¸‹è¡°å‡ï¼ˆå‡å°‘1%ï¼‰
  252   3                  if(max_value[i] > min_value[i])  // ç¡®ä¿æœ€å¤§å€¼å§‹ç»ˆå¤§äºæœ€å°å€¼
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 5   

  253   3                      max_value[i] -= max_value[i] / 100;
  254   3              }
  255   2          }
  256   1          
  257   1          // æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å°å€¼å’Œæœ€å¤§å€¼
  258   1          for(i = 0; i < SENSOR_COUNT; i++)
  259   1          {
  260   2              // å¼‚å¸¸å€¼æ£€æµ‹ - å¦‚æœè¯»æ•°å¼‚å¸¸å¤§æˆ–å¼‚å¸¸å°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœï¼Œä¸æ›´æ–°
  261   2              if(result[i] > 1000 || result[i] < 5)
  262   2                  continue;
  263   2                  
  264   2              // æ›´æ–°æœ€å°å€¼ï¼ˆå¿½ç•¥è¿‡å°çš„å€¼ï¼Œå¯èƒ½æ˜¯å™ªå£°ï¼‰
  265   2              if(result[i] < min_value[i] && result[i] > 10) 
  266   2                  min_value[i] = result[i];
  267   2              
  268   2              // æ›´æ–°æœ€å¤§å€¼
  269   2              if(result[i] > max_value[i]) 
  270   2                  max_value[i] = result[i];
  271   2          }
  272   1          
  273   1          // ç¡®ä¿æœ€å¤§æœ€å°å€¼ä¹‹é—´æœ‰è¶³å¤Ÿå·®è·ï¼Œé¿å…é™¤ä»¥æ¥è¿‘0çš„å€¼
  274   1          for(i = 0; i < SENSOR_COUNT; i++)
  275   1          {
  276   2              if(max_value[i] - min_value[i] < 20)
  277   2              {
  278   3                  // å¦‚æœå·®è·å¤ªå°ï¼Œå¼ºåˆ¶è®¾ç½®ä¸€ä¸ªåˆç†å·®è·
  279   3                  max_value[i] = min_value[i] + 20;
  280   3              }
  281   2          }
  282   1      }
  283          
  284          //-----------------------------------------------------------------------------
  285          // @brief   å½’ä¸€åŒ–ç”µæ„Ÿæ•°æ®
  286          // @param   æ— 
  287          // @return  æ— 
  288          // @author  ZP
  289          // Sample usage: normalize_sensors();
  290          //-----------------------------------------------------------------------------
  291          void normalize_sensors(void)
  292          {
  293   1          uint8 i;
  294   1          // å¯é€‰ï¼šå¯¹å½’ä¸€åŒ–åçš„æ•°æ®è¿›è¡Œå¹³æ»‘å¤„ç†ï¼Œå‡å°‘æŠ–åŠ¨
  295   1          static float last_normalized[SENSOR_COUNT] = {0};
  296   1          // å¹³æ»‘å› å­ï¼Œå¯è°ƒæ•´ï¼šå€¼è¶Šå¤§ï¼Œå“åº”è¶Šå¿«ä½†æŠ–åŠ¨è¶Šæ˜æ˜¾ï¼Œå€¼è¶Šå°ï¼Œå“åº”è¶Šæ…¢ä½
             -†æ›´å¹³ç¨³
  297   1          float smooth_factor = 0.7f; // å»ºè®®åœ¨0.6-0.8èŒƒå›´å†…è°ƒæ•´ï¼Œæ ¹æ®å°è½¦å®é™…è¡¨ç°å¾®è°ƒ    //
             - é¦–å…ˆæ›´æ–°æœ€å¤§æœ€å°å€¼
  298   1      
  299   1          update_min_max_values();
  300   1          
  301   1          // å¯¹æ¯ä¸ªç”µæ„Ÿè¿›è¡Œå½’ä¸€åŒ–å¤„ç†
  302   1          for(i = 0; i < SENSOR_COUNT; i++)
  303   1          {
  304   2              // æ£€æŸ¥æœ€å¤§æœ€å°å€¼å·®å¼‚æ˜¯å¦è¶³å¤Ÿå¤§ï¼Œé˜²æ­¢é™¤ä»¥æ¥è¿‘0çš„å€¼
  305   2              if(max_value[i] - min_value[i] > 20) 
  306   2              {
  307   3                  // æ ‡å‡†çº¿æ€§å½’ä¸€åŒ–ï¼Œå°†å€¼æ˜ å°„åˆ°0-100èŒƒå›´ï¼ˆä¹˜ä»¥100æ–¹ä¾¿åç»­ä½¿ç”¨ï¼‰
  308   3                  normalized_data[i] = (float)(result[i] - min_value[i]) / (max_value[i] - min_value[i]) * 100.
             -0f;
  309   3                  
  310   3                  // å¯é€‰ï¼šä½¿ç”¨å¹³æ–¹æ ¹éçº¿æ€§æ˜ å°„ï¼Œå¢å¼ºå°ä¿¡å·å“åº”(å¦‚æœå‘ç°å°è½¦å¯¹å°å
             -å·®ååº”ä¸æ•æ„Ÿï¼Œå¯ä»¥å–æ¶ˆå¹³æ–¹æ ¹æ˜ å°„çš„æ³¨é‡Š)
  311   3                  // normalized_data[i] = sqrtf(normalized_data[i] / 100.0f) * 100.0f;
  312   3              }
  313   2              else 
  314   2              {
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 6   

  315   3                  // å¦‚æœæœ€å¤§æœ€å°å€¼å·®å¼‚å¤ªå°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœæˆ–æœªæ­£ç¡®åˆå§‹åŒ–
  316   3                  // ä½¿ç”¨åŸå§‹å€¼çš„ç›¸å¯¹æ¯”ä¾‹ä½œä¸ºæ›¿ä»£ï¼Œä¹Ÿä¹˜ä»¥100ä¿æŒä¸€è‡´æ€§
  317   3                  normalized_data[i] = (float)result[i] / 10.0f;  // å‡è®¾ADCæœ€å¤§å€¼ä¸º1000ï¼Œå½’ä¸€åŒ–åˆ°0-
             -100
  318   3              }
  319   2              
  320   2              // é™åˆ¶èŒƒå›´åœ¨0-100ä¹‹é—´
  321   2              if(normalized_data[i] > 100.0f) normalized_data[i] = 100.0f;
  322   2              if(normalized_data[i] < 0.0f) normalized_data[i] = 0.0f;
  323   2          }
  324   1          
  325   1          for(i = 0; i < SENSOR_COUNT; i++)
  326   1          {
  327   2              // ä½é€šæ»¤æ³¢å¹³æ»‘å¤„ç†
  328   2              normalized_data[i] = normalized_data[i] * smooth_factor + 
  329   2                                  last_normalized[i] * (1.0f - smooth_factor);
  330   2              
  331   2              // ä¿å­˜å½“å‰å€¼ç”¨äºä¸‹æ¬¡å¹³æ»‘
  332   2              last_normalized[i] = normalized_data[i];
  333   2          }
  334   1      }
  335          
  336          //-----------------------------------------------------------------------------
  337          // @brief   æ”¹è¿›ç‰ˆè®¡ç®—ä½ç½®ï¼ˆä½¿ç”¨è‡ªé€‚åº”å·®æ¯”å’ŒåŠ æƒæ–¹æ³•ï¼‰
  338          // @param   æ— 
  339          // @return  è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼ï¼ŒèŒƒå›´-100åˆ°100
  340          // @author  ZP
  341          // Sample usage: position = calculate_position_improved();
  342          //-----------------------------------------------------------------------------
  343          int16 calculate_position_improved(void)
  344          {
  345   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
  346   1          float weight_L_R = 0.7f;   // å·¦å³ç”µæ„Ÿæƒé‡
  347   1          float weight_LM_RM = 0.3f; // å·¦ä¸­å³ä¸­ç”µæ„Ÿæƒé‡
  348   1          float diff_L_R = 0;        // å·¦å³æ°´å¹³ç”µæ„Ÿå·®å€¼
  349   1          float diff_LM_RM = 0;      // å·¦å³ä¸­é—´ç”µæ„Ÿå·®å€¼
  350   1          float sum_L_R = 0;         // å·¦å³æ°´å¹³ç”µæ„Ÿå’Œå€¼
  351   1          float sum_LM_RM = 0;       // å·¦å³ä¸­é—´ç”µæ„Ÿå’Œå€¼
  352   1          float ratio_L_R = 0;       // å·¦å³ç”µæ„Ÿå·®æ¯”å’Œ
  353   1          float ratio_LM_RM = 0;     // å·¦ä¸­å³ä¸­ç”µæ„Ÿå·®æ¯”å’Œ
  354   1          float signal_strength = 0; // ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  355   1          static int16 last_pos = 0; // ä¸Šä¸€æ¬¡ä½ç½®å€¼ï¼Œç”¨äºæ»¤æ³¢
  356   1          int16 pos = 0;             // å½“å‰è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼
  357   1          float filter_param = 0.7f; // æ»¤æ³¢ç³»æ•°ï¼Œå¯è°ƒ
  358   1          uint8 track_type = 0;      // èµ›é“ç±»å‹ï¼š0-æ™®é€šï¼Œ1-åå­—ï¼Œ2-ç¯å²›ï¼Œ3-å¡é“
  359   1          
  360   1          // è®¡ç®—å„å¯¹ç”µæ„Ÿçš„å·®å€¼å’Œå’Œå€¼
  361   1          diff_L_R = normalized_data[SENSOR_L] - normalized_data[SENSOR_R];
  362   1          sum_L_R = normalized_data[SENSOR_L] + normalized_data[SENSOR_R];
  363   1          
  364   1          diff_LM_RM = normalized_data[SENSOR_LM] - normalized_data[SENSOR_RM];
  365   1          sum_LM_RM = normalized_data[SENSOR_LM] + normalized_data[SENSOR_RM];
  366   1          
  367   1          // è®¡ç®—ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  368   1          signal_strength = (sum_L_R + sum_LM_RM) / 4.0f;
  369   1          
  370   1          // è®¡ç®—å·®æ¯”å’Œï¼Œé¿å…é™¤ä»¥0
  371   1          if(sum_L_R > 1.0f)
  372   1              ratio_L_R = diff_L_R / sum_L_R;
  373   1          else
  374   1              ratio_L_R = 0;
  375   1              
  376   1          if(sum_LM_RM > 1.0f)
  377   1              ratio_LM_RM = diff_LM_RM / sum_LM_RM;
  378   1          else
  379   1              ratio_LM_RM = 0;
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 7   

  380   1          
  381   1          // èµ›é“ç±»å‹è¯†åˆ«
  382   1          // 1. åå­—è·¯å£ç‰¹å¾ï¼šä¸­é—´ç”µæ„Ÿå€¼å¤§ï¼Œä¸¤ä¾§ç”µæ„Ÿå€¼å°
  383   1          if(normalized_data[SENSOR_LM] > 60.0f && normalized_data[SENSOR_RM] > 60.0f && 
  384   1             normalized_data[SENSOR_L] < 30.0f && normalized_data[SENSOR_R] < 30.0f)
  385   1          {
  386   2              track_type = 1; // åå­—è·¯å£
  387   2          }
  388   1          // 2. ç¯å²›ç‰¹å¾ï¼šä¸€ä¾§ç”µæ„Ÿå€¼å¾ˆå¤§ï¼Œå¦ä¸€ä¾§å¾ˆå°
  389   1          else if((normalized_data[SENSOR_L] > 80.0f && normalized_data[SENSOR_R] < 20.0f) ||
  390   1                  (normalized_data[SENSOR_R] > 80.0f && normalized_data[SENSOR_L] < 20.0f))
  391   1          {
  392   2              track_type = 2; // ç¯å²›
  393   2          }
  394   1          // 3. å¡é“ç‰¹å¾ï¼šæ‰€æœ‰ç”µæ„Ÿå€¼éƒ½è¾ƒå¤§
  395   1          else if(normalized_data[SENSOR_L] > 70.0f && normalized_data[SENSOR_R] > 70.0f &&
  396   1                  normalized_data[SENSOR_LM] > 70.0f && normalized_data[SENSOR_RM] > 70.0f)
  397   1          {
  398   2              track_type = 3; // å¡é“
  399   2          }
  400   1          
  401   1          // æ ¹æ®èµ›é“ç±»å‹å’Œä¿¡å·å¼ºåº¦è°ƒæ•´æƒé‡
  402   1          switch(track_type)
  403   1          {
  404   2              case 0: // æ™®é€šèµ›é“
  405   2                  // æ ¹æ®ä¿¡å·å¼ºåº¦åŠ¨æ€è°ƒæ•´æƒé‡
  406   2                  if(signal_strength > 70.0f) // ä¿¡å·å¼ºï¼Œå¯èƒ½åœ¨ç›´é“
  407   2                  {
  408   3                      weight_L_R = 0.6f;
  409   3                      weight_LM_RM = 0.4f;
  410   3                  }
  411   2                  else if(signal_strength < 30.0f) // ä¿¡å·å¼±ï¼Œå¯èƒ½åœ¨å¼¯é“
  412   2                  {
  413   3                      weight_L_R = 0.8f;
  414   3                      weight_LM_RM = 0.2f;
  415   3                  }
  416   2                  break;
  417   2                  
  418   2              case 1: // åå­—è·¯å£
  419   2                  // åå­—è·¯å£æ›´ä¾èµ–ä¸­é—´ç”µæ„Ÿ
  420   2                  weight_L_R = 0.3f;
  421   2                  weight_LM_RM = 0.7f;
  422   2                  break;
  423   2                  
  424   2              case 2: // ç¯å²›
  425   2                  // ç¯å²›æ›´ä¾èµ–å¤–ä¾§ç”µæ„Ÿ
  426   2                  weight_L_R = 0.9f;
  427   2                  weight_LM_RM = 0.1f;
  428   2                  break;
  429   2                  
  430   2              case 3: // å¡é“
  431   2                  // å¡é“ä½¿ç”¨å¹³å‡æƒé‡
  432   2                  weight_L_R = 0.5f;
  433   2                  weight_LM_RM = 0.5f;
  434   2                  break;
  435   2          }
  436   1          
  437   1          // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå½“æ‰€æœ‰ç”µæ„Ÿå€¼éƒ½å¾ˆå°æ—¶ï¼Œå¯èƒ½å·²ç»åç¦»èµ›é“
  438   1          if(sum_L_R < 10.0f && sum_LM_RM < 10.0f)
  439   1          {
  440   2              // æ ¹æ®ä¸Šä¸€æ¬¡ä½ç½®åˆ¤æ–­åç¦»æ–¹å‘
  441   2              if(last_pos > 0)
  442   2                  return 100;  // å‘å³åç¦»
  443   2              else
  444   2                  return -100; // å‘å·¦åç¦»
  445   2          }
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 8   

  446   1          
  447   1          // å·®æ¯”å’ŒåŠ æƒå¹³å‡
  448   1          pos = (int16)((ratio_L_R * weight_L_R + ratio_LM_RM * weight_LM_RM) * 100.0f);
  449   1          
  450   1          // é™åˆ¶èŒƒå›´åœ¨-100åˆ°100ä¹‹é—´
  451   1          if(pos > 100) pos = 100;
  452   1          if(pos < -100) pos = -100;
  453   1          
  454   1          // æ ¹æ®èµ›é“ç±»å‹è°ƒæ•´æ»¤æ³¢å‚æ•°
  455   1          if(track_type == 0) // æ™®é€šèµ›é“
  456   1          {
  457   2              // æ ¹æ®ä¿¡å·å¼ºåº¦è°ƒæ•´æ»¤æ³¢å‚æ•°
  458   2              if(signal_strength > 70.0f) // ä¿¡å·å¼ºï¼Œå¯èƒ½åœ¨ç›´é“
  459   2                  filter_param = 0.8f; // å“åº”æ›´å¿«
  460   2              else
  461   2                  filter_param = 0.6f; // æ›´å¹³æ»‘
  462   2          }
  463   1          else if(track_type == 1) // åå­—è·¯å£
  464   1          {
  465   2              filter_param = 0.5f; // åå­—è·¯å£éœ€è¦æ›´å¹³æ»‘çš„æ§åˆ¶
  466   2          }
  467   1          else if(track_type == 2) // ç¯å²›
  468   1          {
  469   2              filter_param = 0.9f; // ç¯å²›éœ€è¦æ›´å¿«çš„å“åº”
  470   2          }
  471   1          
  472   1          // æ·»åŠ è‡ªé€‚åº”ä½é€šæ»¤æ³¢ï¼Œå‡å°‘æŠ–åŠ¨
  473   1          pos = (int16)(filter_param * pos + (1-filter_param) * last_pos);
  474   1          last_pos = pos;
  475   1          
  476   1          return pos;
  477   1      }
  478          
  479          
  480          //-----------------------------------------------------------------------------
  481          // @brief   ç”µç£ä¿æŠ¤é€»è¾‘å‡½æ•°
  482          // @param   æ— 
  483          // @return  ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  484          // @author  ZP
  485          // Sample usage: protection_flag = check_electromagnetic_protection();
  486          //-----------------------------------------------------------------------------
  487          uint8 check_electromagnetic_protection(void)
  488          {
  489   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
  490   1          uint8 is_out_of_track = 0;    // æ ‡è®°æ˜¯å¦è„±ç¦»èµ›é“çš„æ ‡å¿—ä½
  491   1          uint16 sum_value = 0;         // æ‰€æœ‰ç”µæ„Ÿå€¼çš„æ€»å’Œ
  492   1          uint16 threshold = 100;       // é˜ˆå€¼ï¼Œéœ€è¦æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ï¼Œåˆ¤æ–­è„±ç¦»èµ›é“çš„ç”µæ„
             -Ÿæ€»å’Œé˜ˆå€¼
  493   1          static uint8 out_of_track_count = 0;    // è¿ç»­æ£€æµ‹åˆ°è„±ç¦»èµ›é“çš„æ¬¡æ•°è®¡æ•°å™¨
  494   1          static uint8 protection_triggered = 0;  // ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  495   1          uint8 i;
  496   1          
  497   1          // è®¡ç®—æ‰€æœ‰ç”µæ„Ÿçš„å’Œå€¼
  498   1          for(i = 0; i < SENSOR_COUNT; i++)
  499   1          {
  500   2              sum_value += result[i];
  501   2          }
  502   1          
  503   1          // åˆ¤æ–­æ˜¯å¦è„±ç¦»èµ›é“çš„æ¡ä»¶
  504   1          // 1. æ‰€æœ‰ç”µæ„Ÿå€¼æ€»å’Œè¿‡å°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
  505   1          if(sum_value < threshold)
  506   1          {
  507   2              is_out_of_track = 1;
  508   2          }
  509   1          
  510   1          // 2. å½’ä¸€åŒ–åçš„å€¼éƒ½å¾ˆå°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 9   

  511   1          if(normalized_data[SENSOR_L] < 5.0f && normalized_data[SENSOR_LM] < 5.0f && 
  512   1             normalized_data[SENSOR_RM] < 5.0f && normalized_data[SENSOR_R] < 5.0f)
  513   1          {
  514   2              is_out_of_track = 1;
  515   2          }
  516   1          
  517   1          // 3. ä½ç½®åå·®è¿‡å¤§ï¼Œè¯´æ˜å¯èƒ½åç¦»èµ›é“å¤ªå¤š
  518   1          if(position < -90 || position > 90)
  519   1          {
  520   2              // åªæœ‰å½“ç”µæ„Ÿå€¼æ€»å’Œä¹Ÿè¾ƒå°æ—¶æ‰åˆ¤æ–­ä¸ºå‡ºèµ›é“
  521   2              if(sum_value < threshold * 2)
  522   2              {
  523   3                  is_out_of_track = 1;
  524   3              }
  525   2          }
  526   1          
  527   1          // è¿ç»­æ£€æµ‹é€»è¾‘ï¼Œé˜²æ­¢å¶ç„¶çš„ä½å€¼å¯¼è‡´è¯¯åˆ¤
  528   1          if(is_out_of_track)
  529   1          {
  530   2              out_of_track_count++;
  531   2              if(out_of_track_count >= 5)  // è¿ç»­5æ¬¡æ£€æµ‹åˆ°è„±ç¦»èµ›é“æ‰è§¦å‘ä¿æŠ¤
  532   2              {
  533   3                  protection_triggered = 1;
  534   3              }
  535   2          }
  536   1          else
  537   1          {
  538   2              // å¦‚æœæ£€æµ‹æ­£å¸¸ï¼Œåˆ™è®¡æ•°å™¨å‡å°‘ä½†ä¸ä½äº0
  539   2              if(out_of_track_count > 0)
  540   2                  out_of_track_count--;
  541   2          }
  542   1          
  543   1          return protection_triggered;
  544   1      }
  545          
  546          // æ˜¾ç¤ºç”µç£ä¼ æ„Ÿå™¨æ•°æ®
  547          void display_electromagnetic_data(void)
  548          {
  549   1          // æ˜¾ç¤ºåŸå§‹æ»¤æ³¢æ•°æ®å’Œå½’ä¸€åŒ–æ•°æ®
  550   1          ips114_showstr_simspi(0,0,"L:");   
  551   1          ips114_showuint16_simspi(3*8, 0, result[SENSOR_L]);
  552   1          ips114_showstr_simspi(9*8,0,"N:");
  553   1          ips114_showfloat_simspi(11*8, 0, normalized_data[SENSOR_L], 2, 2);
  554   1          
  555   1          ips114_showstr_simspi(0,1,"LM:");  
  556   1          ips114_showuint16_simspi(3*8, 1, result[SENSOR_LM]);
  557   1          ips114_showstr_simspi(9*8,1,"N:");
  558   1          ips114_showfloat_simspi(11*8, 1, normalized_data[SENSOR_LM], 2, 2);
  559   1          
  560   1          ips114_showstr_simspi(0,2,"RM:");  
  561   1          ips114_showuint16_simspi(3*8, 2, result[SENSOR_RM]);
  562   1          ips114_showstr_simspi(9*8,2,"N:");
  563   1          ips114_showfloat_simspi(11*8, 2, normalized_data[SENSOR_RM], 2, 2);
  564   1          
  565   1          ips114_showstr_simspi(0,3,"R:");   
  566   1          ips114_showuint16_simspi(3*8, 3, result[SENSOR_R]);
  567   1          ips114_showstr_simspi(9*8,3,"N:");
  568   1          ips114_showfloat_simspi(11*8, 3, normalized_data[SENSOR_R], 2, 2);
  569   1          
  570   1          // æ˜¾ç¤ºä½ç½®å’Œå·®æ¯”å’Œæ•°æ®
  571   1          ips114_showstr_simspi(0,4,"Pos:");
  572   1          ips114_showint16_simspi(5*8, 4, position);
  573   1          
  574   1      } 


C251 COMPILER V5.60.0,  electromagnetic_tracking                                           30/03/25  21:58:22  PAGE 10  

Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4342     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       256     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       283     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
