C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      23/03/25  16:39:54  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_DL1B
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_DL1B.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\seekfree_peripheral\SEEKFREE_DL1B.c XSMALL INTR2 FL
                    -OAT64 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\CODE;..\USER\inc;..\USER\src;..\seekfree_components;..\seekfree
                    -_libraries;..\seekfree_peripheral;..\libraries) DEBUG PRINT(.\Out_File\SEEKFREE_DL1B.lst) TABS(2) OBJECT(.\Out_File\SEEK
                    -FREE_DL1B.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * MM32F527X-E9P Opensourec Library å³ï¼ˆMM32F527X-E9P å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬
             -ä¸‰æ–¹å¼€æºåº“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯ MM32F527X-E9P å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * MM32F527X-E9P å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          zf_device_dl1b
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK 5.37
   28          * é€‚ç”¨å¹³å°          MM32F527X_E9P
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…                å¤‡æ³¨
   33          * 2022-08-10        Teternal            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   SCL                 æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_SCL_PIN  å®å®šä¹‰
   40          *                   SDA                 æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_SDA_PIN  å®å®šä¹‰
   41          *                   XS                  æŸ¥çœ‹ zf_device_dl1b.h ä¸­ DL1B_XS_PIN  å®å®šä¹‰
   42          *                   VCC                 5V ç”µæº
   43          *                   GND                 ç”µæºåœ°
   44          *                   ------------------------------------
   45          *********************************************************************************************************
             -***********/
   46          
   47          #include "zf_delay.h"
   48          #include "SEEKFREE_DL1B.h"
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      23/03/25  16:39:54  PAGE 2   

   49          #include "SEEKFREE_CONFIG.h"
   50          
   51          const unsigned char code imu660ra_config_file[8192];
   52          const unsigned char code dl1b_default_configuration [135];
   53          
   54          uint8 dl1b_init_flag = 0;
   55          uint8 dl1b_finsh_flag = 0;
   56          uint16 dl1b_distance_mm = 8192;
   57          
   58          
   59          
   60          #define dl1b_transfer_8bit_array(tdata, tlen, rdata, rlen)      (dl1b_iic_transfer_8bit_array((tdata), (t
             -len), (rdata), (rlen)))
   61          
   62          
   63          #define GET_DL1B_SDA          DL1B_SDA_PIN
   64          #define DL1B_SDA_LOW()            DL1B_SDA_PIN = 0    //IOå£è¾“å‡ºä½ç”µå¹³
   65          #define DL1B_SDA_HIGH()           DL1B_SDA_PIN = 1    //IOå£è¾“å‡ºé«˜ç”µå¹³
   66          
   67          #define DL1B_SCL_LOW()            DL1B_SCL_PIN = 0    //IOå£è¾“å‡ºä½ç”µå¹³
   68          #define DL1B_SCL_HIGH()           DL1B_SCL_PIN = 1    //IOå£è¾“å‡ºé«˜ç”µå¹³
   69          
   70          #define ack 1      //ä¸»åº”ç­”
   71          #define no_ack 0   //ä»åº”ç­”  
   72          
   73          //-------------------------------------------------------------------------------------------------------
             -------------
   74          //  @brief      æ¨¡æ‹ŸIICå»¶æ—¶
   75          //  @return     void
   76          //  @since      v1.0
   77          //  Sample usage:       å¦‚æœIICé€šè®¯å¤±è´¥å¯ä»¥å°è¯•å¢åŠ jçš„å€¼
   78          //-------------------------------------------------------------------------------------------------------
             -------------
   79          static void dl1b_simiic_delay(void)
   80          {
   81   1          uint16 xdata j=DL1B_SOFT_IIC_DELAY;
   82   1          while(j--);
   83   1      }
   84          
   85          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   86          static void dl1b_simiic_start(void)
   87          {
   88   1          DL1B_SDA_HIGH();
   89   1          DL1B_SCL_HIGH();
   90   1          dl1b_simiic_delay();
   91   1          DL1B_SDA_LOW();
   92   1          dl1b_simiic_delay();
   93   1          DL1B_SCL_LOW();
   94   1      }
   95          
   96          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   97          static void dl1b_simiic_stop(void)
   98          {
   99   1          DL1B_SDA_LOW();
  100   1          DL1B_SCL_LOW();
  101   1          dl1b_simiic_delay();
  102   1          DL1B_SCL_HIGH();
  103   1          dl1b_simiic_delay();
  104   1          DL1B_SDA_HIGH();
  105   1          dl1b_simiic_delay();
  106   1      }
  107          
  108          //ä¸»åº”ç­”(åŒ…å«ack:SDA=0å’Œno_ack:SDA=0)
  109          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  110          static void dl1b_simiic_sendack(unsigned char ack_dat)
  111          {
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      23/03/25  16:39:54  PAGE 3   

  112   1          DL1B_SCL_LOW();
  113   1          dl1b_simiic_delay();
  114   1          if(ack_dat) DL1B_SDA_LOW();
  115   1          else      DL1B_SDA_HIGH();
  116   1          DL1B_SCL_HIGH();
  117   1          dl1b_simiic_delay();
  118   1          DL1B_SCL_LOW();
  119   1          dl1b_simiic_delay();
  120   1      }
  121          
  122          
  123          static int dl1b_sccb_waitack(void)
  124          {
  125   1          DL1B_SCL_LOW();
  126   1          dl1b_simiic_delay();
  127   1          DL1B_SCL_HIGH();
  128   1          dl1b_simiic_delay();
  129   1          if(GET_DL1B_SDA)           //åº”ç­”ä¸ºé«˜ç”µå¹³ï¼Œå¼‚å¸¸ï¼Œé€šä¿¡å¤±è´¥
  130   1          {
  131   2              DL1B_SCL_LOW();
  132   2              return 0;
  133   2          }
  134   1          DL1B_SCL_LOW();
  135   1          dl1b_simiic_delay();
  136   1          return 1;
  137   1      }
  138          
  139          //å­—èŠ‚å‘é€ç¨‹åº
  140          //å‘é€c(å¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯æ˜¯åœ°å€)ï¼Œé€å®Œåæ¥æ”¶ä»åº”ç­”
  141          //ä¸è€ƒè™‘ä»åº”ç­”ä½
  142          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  143          static void dl1b_send_ch(uint8 c)
  144          {
  145   1          uint8 xdata i = 8;
  146   1          while(i--)
  147   1          {
  148   2              if(c & 0x80)  DL1B_SDA_HIGH();//SDA è¾“å‡ºæ•°æ®
  149   2              else      DL1B_SDA_LOW();
  150   2              c <<= 1;
  151   2              dl1b_simiic_delay();
  152   2              DL1B_SCL_HIGH();                //SCL æ‹‰é«˜ï¼Œé‡‡é›†ä¿¡å·
  153   2              dl1b_simiic_delay();
  154   2              DL1B_SCL_LOW();                //SCL æ—¶é’Ÿçº¿æ‹‰ä½
  155   2          }
  156   1          dl1b_sccb_waitack();
  157   1      }
  158          
  159          
  160          //å­—èŠ‚æ¥æ”¶ç¨‹åº
  161          //æ¥æ”¶å™¨ä»¶ä¼ æ¥çš„æ•°æ®ï¼Œæ­¤ç¨‹åºåº”é…åˆ|ä¸»åº”ç­”å‡½æ•°|ä½¿ç”¨
  162          //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  163          static uint8 dl1b_read_ch(uint8 ack_x)
  164          {
  165   1          uint8 xdata i;
  166   1          uint8 xdata c;
  167   1          c=0;
  168   1          DL1B_SCL_LOW();
  169   1          dl1b_simiic_delay();
  170   1          DL1B_SDA_HIGH();
  171   1          for(i=0; i<8; i++)
  172   1          {
  173   2              dl1b_simiic_delay();
  174   2              DL1B_SCL_LOW();         //ç½®æ—¶é’Ÿçº¿ä¸ºä½ï¼Œå‡†å¤‡æ¥æ”¶æ•°æ®ä½
  175   2              dl1b_simiic_delay();
  176   2              DL1B_SCL_HIGH();         //ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ï¼Œä½¿æ•°æ®çº¿ä¸Šæ•°æ®æœ‰æ•ˆ
  177   2              dl1b_simiic_delay();
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      23/03/25  16:39:54  PAGE 4   

  178   2              c<<=1;
  179   2              if(GET_DL1B_SDA)
  180   2              {
  181   3                  c+=1;   //è¯»æ•°æ®ä½ï¼Œå°†æ¥æ”¶çš„æ•°æ®å­˜c
  182   3              }
  183   2          }
  184   1          DL1B_SCL_LOW();
  185   1          dl1b_simiic_delay();
  186   1          dl1b_simiic_sendack(ack_x);
  187   1          return c;
  188   1      }
  189          
  190          
  191          //-------------------------------------------------------------------------------------------------------
             -------------
  192          // å‡½æ•°ç®€ä»‹     è½¯ä»¶ IIC æ¥å£ä¼ è¾“ 8bit æ•°ç»„ å…ˆå†™åè¯»å–
  193          // å‚æ•°è¯´æ˜     *write_data     å‘é€æ•°æ®å­˜æ”¾ç¼“å†²åŒº
  194          // å‚æ•°è¯´æ˜     write_len       å‘é€ç¼“å†²åŒºé•¿åº¦
  195          // å‚æ•°è¯´æ˜     *read_data      è¯»å–æ•°æ®å­˜æ”¾ç¼“å†²åŒº
  196          // å‚æ•°è¯´æ˜     read_len        è¯»å–ç¼“å†²åŒºé•¿åº¦
  197          // è¿”å›å‚æ•°     void
  198          // ä½¿ç”¨ç¤ºä¾‹     iic_transfer_8bit_array(IIC_1, addr, data, 64, data, 64);
  199          // å¤‡æ³¨ä¿¡æ¯
  200          //-------------------------------------------------------------------------------------------------------
             -------------
  201          void dl1b_iic_transfer_8bit_array (const uint8 *write_data, uint32 write_len, uint8 *read_data, uint32 re
             -ad_len)
  202          {
  203   1          dl1b_simiic_start();
  204   1          dl1b_send_ch(DL1B_DEV_ADDR << 1);
  205   1          while(write_len --)
  206   1          {
  207   2              dl1b_send_ch(*write_data ++);
  208   2          }
  209   1          dl1b_simiic_start();
  210   1          dl1b_send_ch(DL1B_DEV_ADDR << 1 | 0x01);
  211   1          while(read_len --)
  212   1          {
  213   2              // å‰é¢7ä½éœ€è¦å›å¤ackï¼Œæœ€å1ä½ä¸éœ€è¦å›å¤ack.
  214   2              *read_data ++ = dl1b_read_ch(read_len != 0);
  215   2          }
  216   1          dl1b_simiic_stop();
  217   1      }
  218          
  219          
  220          
  221          
  222          
  223          //-------------------------------------------------------------------------------------------------------
             -------------
  224          // å‡½æ•°ç®€ä»‹     è¿”å›ä»¥æ¯«ç±³ä¸ºå•ä½çš„èŒƒå›´è¯»æ•°
  225          // å‚æ•°è¯´æ˜     void
  226          // è¿”å›å‚æ•°     void
  227          // ä½¿ç”¨ç¤ºä¾‹     dl1b_get_distance();
  228          // å¤‡æ³¨ä¿¡æ¯     åœ¨å¼€å§‹å•æ¬¡å°„ç¨‹æµ‹é‡åä¹Ÿè°ƒç”¨æ­¤å‡½æ•°
  229          //-------------------------------------------------------------------------------------------------------
             -------------
  230          void dl1b_get_distance (void)
  231          {
  232   1          if(dl1b_init_flag)
  233   1          {
  234   2              uint8 xdata data_buffer[3];
  235   2              int16 dl1b_distance_temp = 0;
  236   2              data_buffer[0] = DL1B_GPIO__TIO_HV_STATUS >> 8;
  237   2              data_buffer[1] = DL1B_GPIO__TIO_HV_STATUS & 0xFF;
  238   2              dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      23/03/25  16:39:54  PAGE 5   

  239   2              if(data_buffer[2])
  240   2              {
  241   3                  data_buffer[0] = DL1B_SYSTEM__INTERRUPT_CLEAR >> 8;
  242   3                  data_buffer[1] = DL1B_SYSTEM__INTERRUPT_CLEAR & 0xFF;
  243   3                  data_buffer[2] = 0x01;
  244   3                  dl1b_transfer_8bit_array(data_buffer, 3, data_buffer, 0);// clear Interrupt
  245   3                  data_buffer[0] = DL1B_RESULT__RANGE_STATUS >> 8;
  246   3                  data_buffer[1] = DL1B_RESULT__RANGE_STATUS & 0xFF;
  247   3                  dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  248   3                  if(0x89 == data_buffer[2])
  249   3                  {
  250   4                      data_buffer[0] = DL1B_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0 >> 8;
  251   4                      data_buffer[1] = DL1B_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0 & 0xFF;
  252   4                      dl1b_transfer_8bit_array(data_buffer, 2, data_buffer, 2);
  253   4                      dl1b_distance_temp = data_buffer[0];
  254   4                      dl1b_distance_temp = (dl1b_distance_temp << 8) | data_buffer[1];
  255   4                      if(dl1b_distance_temp > 4000 || dl1b_distance_temp < 0)
  256   4                      {
  257   5                          dl1b_distance_mm = 8192;
  258   5                          dl1b_finsh_flag = 0;
  259   5                      }
  260   4                      else
  261   4                      {
  262   5                          dl1b_distance_mm = dl1b_distance_temp;
  263   5                          dl1b_finsh_flag = 1;
  264   5                      }
  265   4                  }
  266   3                  else
  267   3                  {
  268   4                      dl1b_distance_mm = 8192;
  269   4                      dl1b_finsh_flag = 0;
  270   4                  }
  271   3              }
  272   2              else
  273   2              {
  274   3                  dl1b_distance_mm = 8192;
  275   3                  dl1b_finsh_flag = 0;
  276   3              }
  277   2          }
  278   1      }
  279          
  280          
  281          
  282          //-------------------------------------------------------------------------------------------------------
             -------------
  283          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– DL1B
  284          // å‚æ•°è¯´æ˜     void
  285          // è¿”å›å‚æ•°     uint8 xdata           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  286          // ä½¿ç”¨ç¤ºä¾‹     dl1b_init();
  287          // å¤‡æ³¨ä¿¡æ¯
  288          //-------------------------------------------------------------------------------------------------------
             -------------
  289          uint8 dl1b_init (void)
  290          {
  291   1          uint8 xdata   return_state    = 0;
  292   1          uint8 xdata   data_buffer[2 + sizeof(dl1b_default_configuration)];
  293   1          uint16 xdata  time_out_count  = 0;
  294   1          do
  295   1          {
  296   2              delay_ms(50);
  297   2              DL1B_XS_PIN = 0;
  298   2              delay_ms(10);
  299   2              DL1B_XS_PIN = 1;
  300   2              delay_ms(50);
  301   2              data_buffer[0] = DL1B_FIRMWARE__SYSTEM_STATUS >> 8;
  302   2              data_buffer[1] = DL1B_FIRMWARE__SYSTEM_STATUS & 0xFF;
C251 COMPILER V5.60.0,  SEEKFREE_DL1B                                                      23/03/25  16:39:54  PAGE 6   

  303   2              dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  304   2              return_state = (0x01 == (data_buffer[2] & 0x01)) ? (0) : (1);
  305   2              if(1 == return_state)
  306   2              {
  307   3                  break;
  308   3              }
  309   2              data_buffer[0] = DL1B_I2C_SLAVE__DEVICE_ADDRESS >> 8;
  310   2              data_buffer[1] = DL1B_I2C_SLAVE__DEVICE_ADDRESS & 0xFF;
  311   2              memcpy(&data_buffer[2], (uint8 *)dl1b_default_configuration, sizeof(dl1b_default_configuration));
  312   2              dl1b_transfer_8bit_array(data_buffer, 2 + sizeof(dl1b_default_configuration), data_buffer, 0);
  313   2              while(1)
  314   2              {
  315   3                  data_buffer[0] = DL1B_GPIO__TIO_HV_STATUS >> 8;
  316   3                  data_buffer[1] = DL1B_GPIO__TIO_HV_STATUS & 0xFF;
  317   3                  dl1b_transfer_8bit_array(data_buffer, 2, &data_buffer[2], 1);
  318   3                  if(0x00 == (data_buffer[2] & 0x01))
  319   3                  {
  320   4                      time_out_count = 0;
  321   4                      break;
  322   4                  }
  323   3                  if(DL1B_TIMEOUT_COUNT < time_out_count ++)
  324   3                  {
  325   4                      return_state = 1;
  326   4                      break;
  327   4                  }
  328   3                  delay_ms(1);
  329   3              }
  330   2              dl1b_init_flag = 1;
  331   2          }
  332   1          while(0);
  333   1          return return_state;
  334   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      9416     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       148     ------
  xdata-const size     =    ------     ------
  edata size           =        25     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        16     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
